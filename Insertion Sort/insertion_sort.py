def insertion_sort(arr):
    # arr - твой список чисел, например [5, 2, 9, 1, 5, 6]
    n = len(arr) # n - сколько чисел в списке (здесь 6)

    # 1. Основной Цикл (Перебор Неотсортированных)
    for i in range(1, n):
        # Зачем? Этот цикл проходит по всем элементам, НАЧИНАЯ СО ВТОРОГО (индекс 1).
        # Мы считаем, что первый элемент (индекс 0) - это наша изначальная
        # "отсортированная" часть.
        # i - это индекс ПЕРВОГО элемента в "неотсортированной" части,
        # который мы сейчас будем брать и вставлять в "отсортированную".

        # 2. Запоминаем Вставляемый Элемент
        key = arr[i]
        # Зачем? Мы "берем в руку" текущий элемент, который нужно вставить.
        # Сохраняем его значение в переменную key, потому что на его месте (arr[i])
        # могут оказаться другие числа, пока мы будем сдвигать элементы влево.

        # 3. Готовимся Искать Место (Индекс для Сравнения)
        j = i - 1
        # Зачем? Мы начнем сравнивать наш key с элементами в УЖЕ отсортированной части.
        # Отсортированная часть находится СЛЕВА от i, то есть до индекса i-1 включительно.
        # j - это индекс последнего элемента в отсортированной части, с которого мы начнем сравнение.
        # Мы будем двигаться НАЗАД (уменьшая j) по отсортированной части.

        # 4. Поиск Места и Сдвиг Больших Элементов (Внутренний Цикл)
        while j >= 0 and arr[j] > key:
            # Зачем? Этот цикл делает две вещи:
            #   а) Находит правильное место для key.
            #   б) Сдвигает все элементы, которые БОЛЬШЕ чем key, на одну позицию ВПРАВО,
            #      чтобы освободить это место.
            # Условия цикла:
            #   j >= 0: Убеждаемся, что мы не вышли за левую границу списка (индекс не стал -1).
            #   arr[j] > key: Проверяем, действительно ли элемент слева (arr[j]) БОЛЬШЕ
            #                 нашего элемента key. Если да, его надо сдвинуть.

            # 5. Сдвиг Элемента Вправо
            arr[j + 1] = arr[j]
            # Берем элемент arr[j] (который больше key) и копируем его на одну позицию ПРАВЕЕ (в arr[j+1]).
            # Если мы тут в первый раз, то arr[j+1] это как раз arr[i] - исходное место key.

            # 6. Двигаемся Дальше Влево
            j -= 1
            # Уменьшаем j на 1, чтобы посмотреть на следующий элемент слева в отсортированной части.
            # Возвращаемся к проверке условия `while`.

        # 7. Вставка Элемента на Место
        # Цикл while закончился. Это значит одно из двух:
        #   - Либо мы дошли до начала списка (j стал -1).
        #   - Либо мы нашли элемент arr[j], который МЕНЬШЕ ИЛИ РАВЕН key.
        # В обоих случаях, ПРАВИЛЬНОЕ место для key - это позиция j+1.
        arr[j + 1] = key
        # Ставим наш сохраненный элемент key на найденное пустое место.

# Пример:
numbers = [5, 2, 9, 1, 5, 6]
insertion_sort(numbers) # Запускаем
print(numbers)          # Получаем: [1, 2, 5, 5, 6, 9]