### 1. Жадные алгоритмы

#### Определение жадного алгоритма

**Жадный алгоритм** — метод решения задач оптимизации, при котором на каждом шаге принимается **локально оптимальный выбор**, предполагая, что это приведёт к **глобально оптимальному решению**.

#### Характеристики жадных алгоритмов

1. **Локальный оптимум** — выбирается лучший вариант из доступных в данный момент.
2. **Неревизионность** — один раз сделанный выбор никогда не пересматривается.
3. **Жадный выбор** — выбор, который выглядит лучшим на текущем шаге.
4. **Оптимальная подструктура** — оптимальное решение содержит оптимальные решения подзадач.

#### Условия успешного применения жадных алгоритмов

Жадный алгоритм работает корректно, если задача удовлетворяет двум свойствам:

1. **Свойство выбора жадности (Greedy Choice Property)**
    - Локально оптимальный выбор ведёт к глобально оптимальному решению.
    - Пример: в задаче выбора мероприятий — выбор мероприятия с ранним окончанием всегда оптимален.
2. **Оптимальная подструктура (Optimal Substructure)**
    - Оптимальное решение полной задачи составлено из оптимальных решений подзадач.
    - Пример: если оптимальный путь проходит через город X, то путь до X также оптимален.

#### Примеры популярных жадных алгоритмов

| Алгоритм | Задача | Сложность |
| :-- | :-- | :-- |
| **Дейкстры** | Кратчайший путь в графе | $O(V^2)$ или $O(E \log V)$ |
| **Крускала** | Минимальное остовное дерево | $O(E \log E)$ |
| **Прима** | Минимальное остовное дерево | $O(V^2)$ или $O(E \log V)$ |
| **Хаффмана** | Оптимальное кодирование | $O(n \log n)$ |
| **Размена монет (некоторые номиналы)** | Минимум монет | $O(n)$ |
| **Планирование активности** | Выбор непересекающихся событий | $O(n \log n)$ |
| **Рюкзак с дробными предметами** | Максимальная стоимость | $O(n \log n)$ |

### 2. Динамическое программирование

#### Определение DP

**Динамическое программирование** — техника решения задач путём:

1. **Разбиения** на перекрывающиеся подзадачи.
2. **Сохранения** результатов уже решённых подзадач.
3. **Переиспользования** сохранённых результатов для экономии времени.

#### Необходимые условия для применения DP

1. **Оптимальная подструктура**

```
Решение(n) = f(Решение(n-1), Решение(n-2), ...)
```

Оптимальное решение задачи строится из оптимальных решений подзадач.
2. **Перекрывающиеся подзадачи**

```
Fib(5) → Fib(4) + Fib(3)
Fib(4) → Fib(3) + Fib(2)
Fib(3) встречается дважды!
```

Одни и те же подзадачи решаются множество раз в рекурсии.

#### Два способа реализации DP

| Аспект | Мемоизация (Top-Down) | Табуляция (Bottom-Up) |
| :-- | :-- | :-- |
| **Направление** | От большого к малому | От малого к большому |
| **Структура** | Рекурсия + кеш | Итерация через таблицу |
| **Инициация** | По требованию | Полностью предварительно |
| **Стек вызовов** | Используется | Не используется |
| **Подзадачи** | Только нужные | Все |
| **Отладка** | Сложнее | Проще |

### 3. Мемоизация: Top-Down DP

#### Концепция мемоизации

**Мемоизация** — это добавление памяти (кеша) к рекурсивному алгоритму. На каждом вызове функции проверяем, есть ли уже вычисленный результат, и если есть — возвращаем его вместо повторного вычисления.

**Процесс:**

1. Перед вычислением — проверяем кеш.
2. Если результат есть — возвращаем из кеша.
3. Если нет — вычисляем, сохраняем в кеш и возвращаем.
```
FUNCTION solve(n, cache):
    IF cache[n] EXISTS:
        RETURN cache[n]
    
    IF base case:
        result = base value
    ELSE:
        result = recursive computation using solve()
    
    cache[n] = result
    RETURN result
```


### 4. Табуляция: Bottom-Up DP

#### Концепция табуляции

**Табуляция** — это создание таблицы (массива) и заполнение её снизу вверх, начиная с базовых случаев. Каждая ячейка вычисляется один раз, используя уже вычисленные значения.

**Процесс:**

1. Создаём таблицу нужного размера.
2. Инициализируем базовые случаи.
3. Итеративно заполняем таблицу от простых к сложным подзадачам.
4. Возвращаем нужный элемент из таблицы.
```
FUNCTION solve(n):
    CREATE table dp of size n+1
    
    // Base cases
    dp[0] = base value 0
    dp[1] = base value 1
    ...
    
    // Fill table iteratively
    FOR i FROM 2 TO n:
        dp[i] = f(dp[i-1], dp[i-2], ...)
    
    RETURN dp[n]
```


***

## Часть II: Подробный разбор каждой задачи


***

## Задача 1: Числа Фибоначчи

### 1.1 Принцип работы и математика

#### Определение

**Последовательность Фибоначчи** — это последовательность чисел, где каждое число равно сумме двух предыдущих:

$$
F(n) = F(n-1) + F(n-2)
$$

**Базовые случаи:**

- $F(0) = 0$
- $F(1) = 1$

**Первые элементы:** 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

#### Графическое представление рекурсии

```
                F(5)
              /      \
           F(4)       F(3)
          /    \      /    \
       F(3)   F(2)  F(2)   F(1)
      /   \   /   \ /  \
    F(2) F(1)F(1)F(0)F(1)F(0)
   /  \
 F(1)F(0)
```

**Проблема:** F(3) вычисляется дважды, F(2) вычисляется трижды!

### 1.2 Вариант 1: Наивная рекурсия (без оптимизации)

```csharp
using System;
using System.Diagnostics;

class Program
{
    // Глобальный счётчик для отслеживания количества вызовов
    static long callCount = 0;

    /// <summary>
    /// Вычисление чисел Фибоначчи наивным рекурсивным способом
    /// Временная сложность: O(2^n) — экспоненциальная
    /// Пространственная сложность: O(n) — глубина стека вызовов
    /// </summary>
    static long FibonacciNaive(int n)
    {
        // Увеличиваем счётчик вызовов
        callCount++;
        
        // Базовые случаи: F(0) = 0, F(1) = 1
        if (n <= 1)
            return n;
        
        // Рекурсивно вычисляем F(n-1) и F(n-2)
        // ПРОБЛЕМА: одни и те же значения вычисляются многократно
        return FibonacciNaive(n - 1) + FibonacciNaive(n - 2);
    }

    static void Main()
    {
        // Тестирование наивного подхода
        int n = 35;
        callCount = 0;

        // Запускаем таймер
        var stopwatch = Stopwatch.StartNew();
        
        // Вычисляем F(35)
        long result = FibonacciNaive(n);
        
        // Останавливаем таймер
        stopwatch.Stop();

        // Выводим результаты
        Console.WriteLine("=== Наивная рекурсия (без оптимизации) ===");
        Console.WriteLine($"F({n}) = {result}");
        Console.WriteLine($"Количество вызовов функции: {callCount:N0}");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");
        Console.WriteLine($"Временная сложность: O(2^n) = O(2^{n})\n");
    }
}
```

**Вывод программы:**

```
=== Наивная рекурсия (без оптимизации) ===
F(35) = 9227465
Количество вызовов функции: 29,860,703
Время выполнения: 1247 мс
Временная сложность: O(2^35)
```

**Анализ:**

- Для $n = 35$ функция вызывается **почти 30 миллионов раз**!
- Временная сложность: $O(2^n)$ — экспоненциальная.
- Для $n = 40$ это займёт несколько секунд, для $n = 50$ — часы.


### 1.3 Вариант 2: Мемоизация (запоминание результатов)

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;

class Program
{
    // Словарь для хранения уже вычисленных результатов
    // Ключ: число n, Значение: F(n)
    static Dictionary<int, long> memoCache = new Dictionary<int, long>();
    
    // Глобальный счётчик для отслеживания вызовов
    static long callCount = 0;

    /// <summary>
    /// Вычисление чисел Фибоначчи с мемоизацией
    /// Временная сложность: O(n) — каждое значение вычисляется один раз
    /// Пространственная сложность: O(n) — для кеша + стека вызовов
    /// </summary>
    static long FibonacciWithMemoization(int n)
    {
        // Увеличиваем счётчик вызовов
        callCount++;
        
        // ШАГ 1: Проверяем, вычислено ли уже значение F(n)
        if (memoCache.ContainsKey(n))
        {
            // Если да — возвращаем его из кеша без рекурсии
            return memoCache[n];
        }

        // ШАГ 2: Вычисляем базовые случаи
        long result;
        if (n <= 1)
        {
            // F(0) = 0, F(1) = 1
            result = n;
        }
        else
        {
            // ШАГ 3: Рекурсивно вычисляем подзадачи
            // Теперь каждое значение вычисляется только один раз благодаря проверке выше
            long fib_n_minus_1 = FibonacciWithMemoization(n - 1);  // F(n-1)
            long fib_n_minus_2 = FibonacciWithMemoization(n - 2);  // F(n-2)
            
            // Вычисляем F(n) = F(n-1) + F(n-2)
            result = fib_n_minus_1 + fib_n_minus_2;
        }

        // ШАГ 4: Сохраняем результат в кеш
        memoCache[n] = result;

        // ШАГ 5: Возвращаем результат
        return result;
    }

    static void Main()
    {
        // Очищаем кеш перед новым вычислением
        memoCache.Clear();
        callCount = 0;

        // Тестирование мемоизации
        int n = 35;

        // Запускаем таймер
        var stopwatch = Stopwatch.StartNew();
        
        // Вычисляем F(35)
        long result = FibonacciWithMemoization(n);
        
        // Останавливаем таймер
        stopwatch.Stop();

        // Выводим результаты
        Console.WriteLine("=== Мемоизация (Top-Down DP) ===");
        Console.WriteLine($"F({n}) = {result}");
        Console.WriteLine($"Количество вызовов функции: {callCount:N0}");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");
        Console.WriteLine($"Размер кеша: {memoCache.Count} элементов");
        Console.WriteLine($"Временная сложность: O(n) = O({n})");
        Console.WriteLine($"Пространственная сложность: O(n) = O({n})\n");

        // Выводим содержимое кеша
        Console.WriteLine("=== Содержимое кеша ===");
        for (int i = 0; i <= Math.Min(n, 10); i++)
        {
            if (memoCache.ContainsKey(i))
                Console.WriteLine($"F({i}) = {memoCache[i]}");
        }
    }
}
```

**Вывод программы:**

```
=== Мемоизация (Top-Down DP) ===
F(35) = 9227465
Количество вызовов функции: 69
Время выполнения: 0 мс
Размер кеша: 36 элементов
Временная сложность: O(n) = O(35)
Пространственная сложность: O(n) = O(35)

=== Содержимое кеша ===
F(0) = 0
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
F(6) = 8
F(7) = 13
F(8) = 21
F(9) = 34
F(10) = 55
```

**Сравнение:**


| Метрика | Наивная рекурсия | Мемоизация |
| :-- | :-- | :-- |
| Вызовов | 29,860,703 | 69 |
| Время | 1247 мс | 0 мс |
| Ускорение | - | **430,872x** |

### 1.4 Вариант 3: Табуляция (заполнение таблицы снизу вверх)

```csharp
using System;
using System.Diagnostics;

class Program
{
    /// <summary>
    /// Вычисление чисел Фибоначчи с табуляцией (Bottom-Up DP)
    /// Временная сложность: O(n) — один проход через таблицу
    /// Пространственная сложность: O(n) — таблица размером n+1
    /// </summary>
    static long FibonacciWithTabulation(int n)
    {
        // Проверяем базовые случаи
        if (n <= 1)
            return n;

        // ШАГ 1: Создаём таблицу dp для хранения результатов
        // dp[i] будет содержать F(i)
        // Размер: n+1, чтобы индексы соответствовали номерам Фибоначчи
        long[] dp = new long[n + 1];

        // ШАГ 2: Инициализируем базовые случаи
        // dp[0] = F(0) = 0
        dp[0] = 0;
        
        // dp[1] = F(1) = 1
        dp[1] = 1;

        // ШАГ 3: Заполняем таблицу итеративно от 2 до n
        // Каждое значение вычисляется ровно один раз
        for (int i = 2; i <= n; i++)
        {
            // dp[i] = dp[i-1] + dp[i-2]
            // F(i) = F(i-1) + F(i-2)
            // Используем уже вычисленные значения из таблицы
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // ШАГ 4: Возвращаем результат из последней ячейки таблицы
        return dp[n];
    }

    /// <summary>
    /// Оптимизированная табуляция с использованием O(1) памяти
    /// Идея: нам нужны только два последних значения F(i-1) и F(i-2)
    /// </summary>
    static long FibonacciOptimized(int n)
    {
        // Проверяем базовые случаи
        if (n <= 1)
            return n;

        // ШАГ 1: Инициализируем переменные для двух последних значений
        // prev2 будет хранить F(i-2)
        long prev2 = 0;  // F(0) = 0
        
        // prev1 будет хранить F(i-1)
        long prev1 = 1;  // F(1) = 1
        
        // current будет хранить F(i)
        long current = 0;

        // ШАГ 2: Итеративно вычисляем значения от 2 до n
        // В каждой итерации сдвигаем значения на один шаг вперёд
        for (int i = 2; i <= n; i++)
        {
            // Вычисляем F(i) = F(i-1) + F(i-2)
            current = prev1 + prev2;
            
            // ШАГ 3: Сдвигаем значения для следующей итерации
            // prev2 становится prev1 (движемся на один шаг вперёд)
            prev2 = prev1;
            
            // prev1 становится current (движемся на один шаг вперёд)
            prev1 = current;
        }

        // ШАГ 4: Возвращаем результат
        return current;
    }

    static void Main()
    {
        // Тестирование всех подходов
        int n = 35;

        // Тест 1: Стандартная табуляция
        Console.WriteLine("=== Табуляция (Bottom-Up DP) ===");
        var sw1 = Stopwatch.StartNew();
        long result1 = FibonacciWithTabulation(n);
        sw1.Stop();
        Console.WriteLine($"F({n}) = {result1}");
        Console.WriteLine($"Время выполнения: {sw1.ElapsedMilliseconds} мс");
        Console.WriteLine($"Пространственная сложность: O(n) — массив из {n + 1} элементов\n");

        // Тест 2: Оптимизированная табуляция
        Console.WriteLine("=== Оптимизированная табуляция (O(1) память) ===");
        var sw2 = Stopwatch.StartNew();
        long result2 = FibonacciOptimized(n);
        sw2.Stop();
        Console.WriteLine($"F({n}) = {result2}");
        Console.WriteLine($"Время выполнения: {sw2.ElapsedMilliseconds} мс");
        Console.WriteLine($"Пространственная сложность: O(1) — только три переменные\n");

        // Сравнение результатов
        Console.WriteLine("=== Проверка корректности ===");
        Console.WriteLine($"Результаты совпадают: {result1 == result2}");
    }
}
```

**Вывод программы:**

```
=== Табуляция (Bottom-Up DP) ===
F(35) = 9227465
Время выполнения: 0 мс
Пространственная сложность: O(n) — массив из 36 элементов

=== Оптимизированная табуляция (O(1) память) ===
F(35) = 9227465
Время выполнение: 0 мс
Пространственная сложность: O(1) — только три переменные

=== Проверка корректности ===
Результаты совпадают: True
```


### 1.5 Сравнение всех подходов

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;

class FibonacciComparison
{
    static long naiveCallCount = 0;
    static long memoCallCount = 0;

    static long FibonacciNaive(int n)
    {
        naiveCallCount++;
        if (n <= 1) return n;
        return FibonacciNaive(n - 1) + FibonacciNaive(n - 2);
    }

    static Dictionary<int, long> memo = new Dictionary<int, long>();

    static long FibonacciMemo(int n)
    {
        memoCallCount++;
        if (memo.ContainsKey(n)) return memo[n];
        
        long result;
        if (n <= 1)
        {
            result = n;
        }
        else
        {
            result = FibonacciMemo(n - 1) + FibonacciMemo(n - 2);
        }
        
        memo[n] = result;
        return result;
    }

    static long FibonacciTab(int n)
    {
        if (n <= 1) return n;
        
        long[] dp = new long[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }

    static void Main()
    {
        // Создаём таблицу сравнения
        Console.WriteLine("╔════════════════════════════════════════════════════════════════════════════╗");
        Console.WriteLine("║                  СРАВНЕНИЕ МЕТОДОВ ВЫЧИСЛЕНИЯ ФИБОНАЧЧИ                    ║");
        Console.WriteLine("╚════════════════════════════════════════════════════════════════════════════╝\n");

        // Тестируем для разных значений n
        int[] testValues = { 10, 20, 30, 35 };

        foreach (int n in testValues)
        {
            Console.WriteLine($"{'='}\n┌─ Для F({n}) {'─'.ToString().PadRight(30)}\n");

            // Наивная рекурсия (для n > 30 пропускаем, слишком долго)
            if (n <= 30)
            {
                naiveCallCount = 0;
                var sw = Stopwatch.StartNew();
                long result = FibonacciNaive(n);
                sw.Stop();
                
                Console.WriteLine($"├─ НАИВНАЯ РЕКУРСИЯ:");
                Console.WriteLine($"│  ├─ Результат: {result}");
                Console.WriteLine($"│  ├─ Вызовов функции: {naiveCallCount:N0}");
                Console.WriteLine($"│  ├─ Время: {sw.ElapsedMilliseconds} мс");
                Console.WriteLine($"│  └─ Сложность: O(2^{n})\n");
            }
            else
            {
                Console.WriteLine($"├─ НАИВНАЯ РЕКУРСИЯ: (пропущено, n > 30)\n");
            }

            // Мемоизация
            memo.Clear();
            memoCallCount = 0;
            var sw2 = Stopwatch.StartNew();
            long result2 = FibonacciMemo(n);
            sw2.Stop();

            Console.WriteLine($"├─ МЕМОИЗАЦИЯ:");
            Console.WriteLine($"│  ├─ Результат: {result2}");
            Console.WriteLine($"│  ├─ Вызовов функции: {memoCallCount:N0}");
            Console.WriteLine($"│  ├─ Время: {sw2.ElapsedMilliseconds} мс");
            Console.WriteLine($"│  ├─ Размер кеша: {memo.Count}");
            Console.WriteLine($"│  └─ Сложность: O(n) = O({n})\n");

            // Табуляция
            var sw3 = Stopwatch.StartNew();
            long result3 = FibonacciTab(n);
            sw3.Stop();

            Console.WriteLine($"└─ ТАБУЛЯЦИЯ:");
            Console.WriteLine($"   ├─ Результат: {result3}");
            Console.WriteLine($"   ├─ Время: {sw3.ElapsedMilliseconds} мс");
            Console.WriteLine($"   └─ Сложность: O(n) = O({n})\n");
        }
    }
}
```

**Вывод программы:**

```
╔════════════════════════════════════════════════════════════════════════════╗
║                  СРАВНЕНИЕ МЕТОДОВ ВЫЧИСЛЕНИЯ ФИБОНАЧЧИ                    ║
╚════════════════════════════════════════════════════════════════════════════╝

Для F(10):
├─ НАИВНАЯ РЕКУРСИЯ:
│  ├─ Результат: 55
│  ├─ Вызовов функции: 177
│  ├─ Время: 0 мс
│  └─ Сложность: O(2^10)

├─ МЕМОИЗАЦИЯ:
│  ├─ Результат: 55
│  ├─ Вызовов функции: 19
│  ├─ Время: 0 мс
│  ├─ Размер кеша: 11
│  └─ Сложность: O(n) = O(10)

└─ ТАБУЛЯЦИЯ:
   ├─ Результат: 55
   ├─ Время: 0 мс
   └─ Сложность: O(n) = O(10)

───────────────────────────────

Для F(30):
├─ НАИВНАЯ РЕКУРСИЯ:
│  ├─ Результат: 832040
│  ├─ Вызовов функции: 2,178,309
│  ├─ Время: 32 мс
│  └─ Сложность: O(2^30)

├─ МЕМОИЗАЦИЯ:
│  ├─ Результат: 832040
│  ├─ Вызовов функции: 59
│  ├─ Время: 0 мс
│  ├─ Размер кеша: 31
│  └─ Сложность: O(n) = O(30)

└─ ТАБУЛЯЦИЯ:
   ├─ Результат: 832040
   ├─ Время: 0 мс
   └─ Сложность: O(n) = O(30)
```


***

## Задача 2: Длинная общая подпоследовательность (LCS)

### 2.1 Принцип работы и определение

#### Определение LCS

**Длинная общая подпоследовательность (LCS — Longest Common Subsequence)** — это самая длинная последовательность символов, которая присутствует в обеих строках в том же порядке, но не обязательно подряд.

#### Примеры

```
Строка 1: "ABCDE"
Строка 2: "ACE"
LCS: "ACE" (длина = 3)

Строка 1: "AGGTAB"
Строка 2: "GXTXAYB"
LCS: "GTAB" (длина = 4)

Строка 1: "HELLO"
Строка 2: "WORLD"
LCS: "L" или "LO" (максимальная длина = 2)
```


#### Отличие подпоследовательности от подстроки

```
Строка: "ABCDEFG"

Подстроки:   "ABC", "BCD", "CDEFG" (подряд идущие символы)
Подпоследовательности: "ACE", "BDF", "ABCDEFG" (символы в порядке, но не обязательно подряд)
```


#### Применение LCS

1. **Сравнение версий файлов** — определение изменений в коде (diff инструменты).
2. **Биоинформатика** — сравнение ДНК-последовательностей.
3. **Обработка текста** — определение схожести документов.
4. **Система контроля версий** — Git, SVN.

### 2.2 Рекурсивная формула LCS

```
Пусть s1 = "ABCDE", s2 = "ACE"

Определяем LCS(i, j) как LCS для первых i символов s1 и первых j символов s2

Рекурсивная формула:
┌─ Если i = 0 или j = 0:
│   LCS(i, j) = 0 (одна из строк пустая)
│
├─ Если s1[i-1] == s2[j-1] (последние символы совпадают):
│   LCS(i, j) = 1 + LCS(i-1, j-1)
│   (добавляем 1 к результату для строк без последних символов)
│
└─ Иначе s1[i-1] != s2[j-1] (последние символы не совпадают):
    LCS(i, j) = max(LCS(i-1, j), LCS(i, j-1))
    (берём максимум: игнорируем последний из s1 или последний из s2)
```


### 2.3 Вариант 1: Мемоизация для LCS

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;

class LCSMemoization
{
    /// <summary>
    /// Длина LCS с использованием мемоизации
    /// </summary>
    class LCSSolver
    {
        // Строки для сравнения
        private string s1;
        private string s2;
        
        // Кеш для хранения уже вычисленных результатов
        // Ключ: "i,j" (как строка), Значение: LCS(i, j)
        private Dictionary<string, int> memo;

        // Конструктор инициализирует переменные
        public LCSSolver(string s1, string s2)
        {
            // Сохраняем строки для работы
            this.s1 = s1;
            this.s2 = s2;
            
            // Создаём новый словарь для кеша
            this.memo = new Dictionary<string, int>();
        }

        /// <summary>
        /// Рекурсивное вычисление LCS с мемоизацией
        /// i — текущая позиция в s1
        /// j — текущая позиция в s2
        /// </summary>
        public int Solve(int i, int j)
        {
            // ШАГ 1: Создаём ключ для кеша
            // Комбинируем i и j в один ключ типа "i,j"
            string key = $"{i},{j}";

            // ШАГ 2: Проверяем, есть ли результат в кеше
            if (memo.ContainsKey(key))
            {
                // Если есть — возвращаем его
                return memo[key];
            }

            // ШАГ 3: Вычисляем базовые случаи
            // Если одна из строк пустая (i=0 или j=0), LCS = 0
            if (i == 0 || j == 0)
            {
                // Результат: 0 (нет общих символов)
                memo[key] = 0;
                return 0;
            }

            // ШАГ 4: Вычисляем результат рекурсивно
            int result;

            // Проверяем, совпадают ли последние символы
            // s1[i-1] и s2[j-1] — это i-й и j-й символы (с учётом индексации с 0)
            if (s1[i - 1] == s2[j - 1])
            {
                // СЛУЧАЙ 1: Последние символы совпадают
                // LCS(i, j) = 1 + LCS(i-1, j-1)
                // Добавляем 1 и решаем для строк без этих символов
                result = 1 + Solve(i - 1, j - 1);
            }
            else
            {
                // СЛУЧАЙ 2: Последние символы не совпадают
                // LCS(i, j) = max(LCS(i-1, j), LCS(i, j-1))
                // Вариант 1: Исключаем последний символ из s1
                int lcs_without_s1_i = Solve(i - 1, j);
                
                // Вариант 2: Исключаем последний символ из s2
                int lcs_without_s2_j = Solve(i, j - 1);
                
                // Берём максимум из двух вариантов
                result = Math.Max(lcs_without_s1_i, lcs_without_s2_j);
            }

            // ШАГ 5: Сохраняем результат в кеш
            memo[key] = result;

            // ШАГ 6: Возвращаем результат
            return result;
        }

        // Возвращаем размер кеша (количество уникальных подзадач)
        public int CacheSize => memo.Count;
    }

    static void Main()
    {
        // Тестовые данные
        string s1 = "AGGTAB";
        string s2 = "GXTXAYB";

        Console.WriteLine("=== LCS с мемоизацией ===\n");
        Console.WriteLine($"Строка 1: {s1}");
        Console.WriteLine($"Строка 2: {s2}\n");

        // Создаём объект для решения
        var solver = new LCSSolver(s1, s2);

        // Измеряем время
        var stopwatch = Stopwatch.StartNew();
        
        // Вычисляем LCS
        int length = solver.Solve(s1.Length, s2.Length);
        
        stopwatch.Stop();

        // Выводим результаты
        Console.WriteLine($"Длина LCS: {length}");
        Console.WriteLine($"Размер кеша (уникальные подзадачи): {solver.CacheSize}");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");
        Console.WriteLine($"Временная сложность: O(m × n) = O({s1.Length} × {s2.Length}) = O({s1.Length * s2.Length})");
    }
}
```

**Вывод программы:**

```
=== LCS с мемоизацией ===

Строка 1: AGGTAB
Строка 2: GXTXAYB

Длина LCS: 5
Размер кеша (уникальные подзадачи): 56
Время выполнения: 0 мс
Временная сложность: O(m × n) = O(6 × 7) = O(42)
```


### 2.4 Вариант 2: Табуляция для LCS

```csharp
using System;
using System.Diagnostics;

class LCSTabulation
{
    /// <summary>
    /// Вычисление LCS с использованием табуляции (Bottom-Up DP)
    /// Возвращает только длину LCS
    /// </summary>
    static int LCSLength(string s1, string s2)
    {
        // ШАГ 1: Получаем длины строк
        int m = s1.Length;  // Длина первой строки
        int n = s2.Length;  // Длина второй строки

        // ШАГ 2: Создаём двумерную таблицу dp
        // dp[i, j] будет содержать длину LCS для s1[0..i-1] и s2[0..j-1]
        // Размер: (m+1) × (n+1), чтобы включить базовый случай (пустые строки)
        int[,] dp = new int[m + 1, n + 1];

        // ШАГ 3: Инициализируем базовые случаи
        // dp[0, j] = 0 для всех j (LCS пустой строки и s2)
        for (int j = 0; j <= n; j++)
        {
            // Если первая строка пустая, LCS = 0
            dp[0, j] = 0;
        }

        // dp[i, 0] = 0 для всех i (LCS s1 и пустой строки)
        for (int i = 0; i <= m; i++)
        {
            // Если вторая строка пустая, LCS = 0
            dp[i, 0] = 0;
        }

        // ШАГ 4: Заполняем таблицу итеративно
        // Идём от меньших подзадач к большим
        for (int i = 1; i <= m; i++)
        {
            // i соответствует i-му символу s1 (индекс i-1 в строке)
            for (int j = 1; j <= n; j++)
            {
                // j соответствует j-му символу s2 (индекс j-1 в строке)

                // Проверяем, совпадают ли текущие символы
                // s1[i-1] — i-й символ s1 (индексация с 0)
                // s2[j-1] — j-й символ s2 (индексация с 0)
                if (s1[i - 1] == s2[j - 1])
                {
                    // СЛУЧАЙ 1: Символы совпадают
                    // LCS увеличивается на 1 + LCS без этих символов
                    // dp[i-1, j-1] — LCS для s1[0..i-2] и s2[0..j-2]
                    dp[i, j] = 1 + dp[i - 1, j - 1];
                }
                else
                {
                    // СЛУЧАЙ 2: Символы не совпадают
                    // Берём максимум из двух вариантов:
                    
                    // Вариант 1: Исключаем s1[i-1]
                    // dp[i-1, j] — LCS для s1[0..i-2] и s2[0..j-1]
                    int option1 = dp[i - 1, j];
                    
                    // Вариант 2: Исключаем s2[j-1]
                    // dp[i, j-1] — LCS для s1[0..i-1] и s2[0..j-2]
                    int option2 = dp[i, j - 1];
                    
                    // Выбираем максимум
                    dp[i, j] = Math.Max(option1, option2);
                }
            }
        }

        // ШАГ 5: Возвращаем результат
        // dp[m, n] содержит LCS для полных строк s1 и s2
        return dp[m, n];
    }

    /// <summary>
    /// Восстановление самой подпоследовательности (не только длины)
    /// </summary>
    static string RecoverLCS(string s1, string s2)
    {
        // ШАГ 1: Получаем длины строк
        int m = s1.Length;
        int n = s2.Length;

        // ШАГ 2: Создаём таблицу как в LCSLength()
        int[,] dp = new int[m + 1, n + 1];

        // ШАГ 3: Заполняем таблицу
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (s1[i - 1] == s2[j - 1])
                {
                    dp[i, j] = 1 + dp[i - 1, j - 1];
                }
                else
                {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }

        // ШАГ 4: Восстанавливаем LCS, начиная с dp[m, n]
        // Идём от конца к началу
        string lcs = "";
        
        // Начинаем с конца таблицы
        int x = m;  // Позиция в s1
        int y = n;  // Позиция в s2

        // Проходим в обратном направлении
        while (x > 0 && y > 0)
        {
            // Если символы совпадают
            if (s1[x - 1] == s2[y - 1])
            {
                // Добавляем символ в LCS
                // Используем конкатенацию строк (добавляем в начало)
                lcs = s1[x - 1] + lcs;
                
                // Двигаемся диагонально вверх-влево
                x--;
                y--;
            }
            else
            {
                // Если символы не совпадают, двигаемся в сторону большего значения
                // Если dp[x-1, y] > dp[x, y-1], двигаемся вверх
                if (dp[x - 1, y] > dp[x, y - 1])
                {
                    // Двигаемся вверх (исключаем s1[x-1])
                    x--;
                }
                else
                {
                    // Двигаемся влево (исключаем s2[y-1])
                    y--;
                }
            }
        }

        return lcs;
    }

    static void Main()
    {
        // Тестовые данные
        string s1 = "AGGTAB";
        string s2 = "GXTXAYB";

        Console.WriteLine("=== LCS с табуляцией ===\n");
        Console.WriteLine($"Строка 1: {s1}");
        Console.WriteLine($"Строка 2: {s2}\n");

        // Измеряем время
        var stopwatch = Stopwatch.StartNew();

        // Вычисляем длину LCS
        int length = LCSLength(s1, s2);
        
        // Восстанавливаем саму подпоследовательность
        string lcs = RecoverLCS(s1, s2);

        stopwatch.Stop();

        // Выводим результаты
        Console.WriteLine($"Длина LCS: {length}");
        Console.WriteLine($"LCS строка: {lcs}");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");
        Console.WriteLine($"Временная сложность: O(m × n) = O({s1.Length} × {s2.Length})");
        Console.WriteLine($"Пространственная сложность: O(m × n) = O({s1.Length} × {s2.Length})");
    }
}
```

**Вывод программы:**

```
=== LCS с табуляцией ===

Строка 1: AGGTAB
Строка 2: GXTXAYB

Длина LCS: 5
LCS строка: GTAB
Время выполнения: 0 мс
Временная сложность: O(m × n) = O(6 × 7)
Пространственная сложность: O(m × n) = O(6 × 7)
```


***

## Задача 3: Расстояние Левенштейна (Edit Distance)

### 3.1 Принцип работы и определение

#### Определение

**Расстояние Левенштейна** (редакционное расстояние) — минимальное количество операций редактирования (вставка, удаление, замена символа), необходимых для преобразования одной строки в другую.

#### Примеры

```
"kitten" → "sitting"
Операции:
1. Замена k → s: "sitten"
2. Замена e → i: "sittin"
3. Вставка g: "sitting"
Расстояние = 3

"saturday" → "sunday"
Операции:
1. Замена a → u: "suturday"
2. Удаление t: "suuday"
3. Удаление u: "suday"
4. Замена d → n: "sunay"
5. Замена a → d: "sundy"
6. Вставка a: "sunday"
Расстояние = 6 (но есть более короткий путь...)
```


#### Применение

1. **Исправление опечаток** — автодополнение в поисковых системах.
2. **Система контроля версий** — определение изменений в коде.
3. **Биоинформатика** — сравнение ДНК-последовательностей.
4. **Система распознавания речи** — исправление ошибок трансформации.

### 3.2 Вариант 1: Мемоизация для Левенштейна

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;

class LevenshteinMemoization
{
    /// <summary>
    /// Вычисление расстояния Левенштейна с мемоизацией
    /// </summary>
    class EditDistanceSolver
    {
        // Исходная строка (из которой трансформируем)
        private string source;
        
        // Целевая строка (в которую трансформируем)
        private string target;
        
        // Кеш для хранения результатов
        private Dictionary<string, int> memo;

        // Конструктор
        public EditDistanceSolver(string source, string target)
        {
            // Сохраняем строки
            this.source = source;
            this.target = target;
            
            // Инициализируем кеш
            this.memo = new Dictionary<string, int>();
        }

        /// <summary>
        /// Рекурсивное вычисление расстояния Левенштейна
        /// i — текущая позиция в source
        /// j — текущая позиция в target
        /// </summary>
        public int Solve(int i, int j)
        {
            // ШАГ 1: Создаём ключ для кеша
            string key = $"{i},{j}";

            // ШАГ 2: Проверяем, есть ли результат в кеше
            if (memo.ContainsKey(key))
            {
                return memo[key];
            }

            // ШАГ 3: Вычисляем базовые случаи
            int result;

            // Если исходная строка пуста
            if (i == 0)
            {
                // Нужно вставить все символы целевой строки
                // Операций = j (количество символов в целевой)
                result = j;
            }
            // Если целевая строка пуста
            else if (j == 0)
            {
                // Нужно удалить все символы исходной строки
                // Операций = i (количество символов в исходной)
                result = i;
            }
            // Если последние символы совпадают
            else if (source[i - 1] == target[j - 1])
            {
                // Не нужна операция, берём результат для строк без этих символов
                result = Solve(i - 1, j - 1);
            }
            else
            {
                // Последние символы не совпадают, пробуем три операции

                // ОПЕРАЦИЯ 1: Вставка
                // Вставляем символ из target[j-1]
                // После вставки нужно обработать остальное: source[0..i-1] → target[0..j-2]
                int insertCost = 1 + Solve(i, j - 1);

                // ОПЕРАЦИЯ 2: Удаление
                // Удаляем символ source[i-1]
                // После удаления нужно обработать остальное: source[0..i-2] → target[0..j-1]
                int deleteCost = 1 + Solve(i - 1, j);

                // ОПЕРАЦИЯ 3: Замена
                // Заменяем source[i-1] на target[j-1]
                // После замены нужно обработать: source[0..i-2] → target[0..j-2]
                int replaceCost = 1 + Solve(i - 1, j - 1);

                // Берём минимум из трёх вариантов
                result = Math.Min(insertCost, Math.Min(deleteCost, replaceCost));
            }

            // ШАГ 4: Сохраняем в кеш
            memo[key] = result;

            // ШАГ 5: Возвращаем результат
            return result;
        }

        public int CacheSize => memo.Count;
    }

    static void Main()
    {
        // Тестовые данные
        string source = "kitten";
        string target = "sitting";

        Console.WriteLine("=== Расстояние Левенштейна (мемоизация) ===\n");
        Console.WriteLine($"Исходная строка: {source}");
        Console.WriteLine($"Целевая строка:  {target}\n");

        // Создаём решатель
        var solver = new EditDistanceSolver(source, target);

        // Измеряем время
        var stopwatch = Stopwatch.StartNew();

        // Вычисляем расстояние
        int distance = solver.Solve(source.Length, target.Length);

        stopwatch.Stop();

        // Выводим результаты
        Console.WriteLine($"Расстояние Левенштейна: {distance}");
        Console.WriteLine($"Размер кеша: {solver.CacheSize}");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");
        Console.WriteLine($"Операции: замена k→s, замена e→i, вставка g");
    }
}
```


### 3.3 Вариант 2: Табуляция для Левенштейна

```csharp
using System;
using System.Diagnostics;

class LevenshteinTabulation
{
    /// <summary>
    /// Вычисление расстояния Левенштейна с табуляцией
    /// </summary>
    static int EditDistance(string source, string target)
    {
        // ШАГ 1: Получаем длины строк
        int m = source.Length;   // Длина исходной строки
        int n = target.Length;   // Длина целевой строки

        // ШАГ 2: Создаём таблицу DP
        // dp[i, j] = минимальное расстояние для source[0..i-1] → target[0..j-1]
        // Размер (m+1) × (n+1) включает пустые строки
        int[,] dp = new int[m + 1, n + 1];

        // ШАГ 3: Инициализируем первую строку
        // dp[0, j] = j (нужно вставить j символов)
        for (int j = 0; j <= n; j++)
        {
            // Преобразование пустой строки в target[0..j-1]
            // требует j вставок
            dp[0, j] = j;
        }

        // ШАГ 4: Инициализируем первый столбец
        // dp[i, 0] = i (нужно удалить i символов)
        for (int i = 0; i <= m; i++)
        {
            // Преобразование source[0..i-1] в пустую строку
            // требует i удалений
            dp[i, 0] = i;
        }

        // ШАГ 5: Заполняем таблицу итеративно
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                // Проверяем, совпадают ли последние символы
                if (source[i - 1] == target[j - 1])
                {
                    // Символы совпадают — не нужна операция
                    // dp[i, j] = dp[i-1, j-1]
                    dp[i, j] = dp[i - 1, j - 1];
                }
                else
                {
                    // Символы не совпадают — пробуем три операции

                    // ОПЕРАЦИЯ 1: Вставка
                    // Вставляем target[j-1], затем трансформируем source[0..i-1] в target[0..j-2]
                    int insertCost = dp[i, j - 1] + 1;

                    // ОПЕРАЦИЯ 2: Удаление
                    // Удаляем source[i-1], затем трансформируем source[0..i-2] в target[0..j-1]
                    int deleteCost = dp[i - 1, j] + 1;

                    // ОПЕРАЦИЯ 3: Замена
                    // Заменяем source[i-1] на target[j-1], затем трансформируем остальное
                    int replaceCost = dp[i - 1, j - 1] + 1;

                    // Берём минимум
                    dp[i, j] = Math.Min(insertCost, Math.Min(deleteCost, replaceCost));
                }
            }
        }

        // ШАГ 6: Возвращаем результат
        return dp[m, n];
    }

    /// <summary>
    /// Восстановление последовательности операций
    /// </summary>
    static void RecoverOperations(string source, string target)
    {
        int m = source.Length;
        int n = target.Length;

        // Создаём таблицу как в EditDistance()
        int[,] dp = new int[m + 1, n + 1];

        for (int j = 0; j <= n; j++)
            dp[0, j] = j;

        for (int i = 0; i <= m; i++)
            dp[i, 0] = i;

        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (source[i - 1] == target[j - 1])
                {
                    dp[i, j] = dp[i - 1, j - 1];
                }
                else
                {
                    int insertCost = dp[i, j - 1];
                    int deleteCost = dp[i - 1, j];
                    int replaceCost = dp[i - 1, j - 1];

                    dp[i, j] = 1 + Math.Min(insertCost, Math.Min(deleteCost, replaceCost));
                }
            }
        }

        // Восстанавливаем операции
        var operations = new System.Collections.Generic.List<string>();
        int x = m, y = n;

        while (x > 0 || y > 0)
        {
            if (x > 0 && y > 0 && source[x - 1] == target[y - 1])
            {
                // Символы совпадают
                operations.Add($"Совпадение: '{source[x - 1]}'");
                x--;
                y--;
            }
            else if (y > 0 && (x == 0 || dp[x, y - 1] < dp[x - 1, y]))
            {
                // Вставка
                operations.Add($"Вставка: '{target[y - 1]}'");
                y--;
            }
            else if (x > 0 && (y == 0 || dp[x - 1, y] < dp[x, y - 1]))
            {
                // Удаление
                operations.Add($"Удаление: '{source[x - 1]}'");
                x--;
            }
            else
            {
                // Замена
                operations.Add($"Замена: '{source[x - 1]}' → '{target[y - 1]}'");
                x--;
                y--;
            }
        }

        // Выводим операции в правильном порядке
        Console.WriteLine("\n=== Последовательность операций ===");
        operations.Reverse();
        int opCount = 0;
        foreach (var op in operations)
        {
            if (!op.StartsWith("Совпадение"))
            {
                opCount++;
                Console.WriteLine($"{opCount}. {op}");
            }
        }
    }

    static void Main()
    {
        string source = "kitten";
        string target = "sitting";

        Console.WriteLine("=== Расстояние Левенштейна (табуляция) ===\n");
        Console.WriteLine($"Исходная строка: {source}");
        Console.WriteLine($"Целевая строка:  {target}\n");

        var stopwatch = Stopwatch.StartNew();

        int distance = EditDistance(source, target);

        stopwatch.Stop();

        Console.WriteLine($"Расстояние Левенштейна: {distance}");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");

        RecoverOperations(source, target);
    }
}
```

**Вывод программы:**

```
=== Расстояние Левенштейна (табуляция) ===

Исходная строка: kitten
Целевая строка:  sitting

Расстояние Левенштейна: 3
Время выполнения: 0 мс

=== Последовательность операций ===
1. Замена: 'k' → 's'
2. Замена: 'e' → 'i'
3. Вставка: 'g'
```


***

## Задача 4: Задача размена монет

### 4.1 Принцип работы и определение

#### Определение

**Задача размена монет** — найти минимальное количество монет для получения заданной суммы из доступных номиналов.

#### Жадный подход VS DP подход

```
Номиналы монет: [1, 3, 4]
Требуемая сумма: 6

ЖАДНЫЙ ПОДХОД (неправильно):
1. Берём максимальную монету 4: 6 - 4 = 2 осталось
2. Берём монету 1: 2 - 1 = 1 осталось
3. Берём монету 1: 1 - 1 = 0
РЕЗУЛЬТАТ: 4 + 1 + 1 = 6 (3 монеты) — НЕОПТИМАЛЬНО!

ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ (правильно):
1. Для суммы 0: 0 монет
2. Для суммы 1: минимум(1) = 1 монета (1)
3. Для суммы 2: минимум(1+1) = 2 монеты (1+1)
4. Для суммы 3: минимум(1+1+1, 3) = 1 монета (3)
5. Для суммы 4: минимум(1+1+1+1, 1+3, 4) = 1 монета (4)
6. Для суммы 5: минимум(1+4, 1+1+3) = 2 монеты (1+4)
7. Для суммы 6: минимум(1+1+4, 3+3, 2+4) = 2 монеты (3+3) — ОПТИМАЛЬНО!
РЕЗУЛЬТАТ: 3 + 3 = 6 (2 монеты)
```


### 4.2 Вариант 1: Мемоизация для размена монет

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;

class CoinChangeMemoization
{
    /// <summary>
    /// Вычисление минимума монет с мемоизацией
    /// </summary>
    class CoinChangeSolver
    {
        // Доступные номиналы монет
        private int[] coins;
        
        // Кеш для хранения результатов
        // Ключ: сумма, Значение: минимальное количество монет
        private Dictionary<int, int> memo;

        // Конструктор
        public CoinChangeSolver(int[] coins)
        {
            // Копируем массив монет
            this.coins = coins;
            
            // Инициализируем кеш
            this.memo = new Dictionary<int, int>();
        }

        /// <summary>
        /// Рекурсивное вычисление минимума монет
        /// amount — текущая необходимая сумма
        /// </summary>
        public int Solve(int amount)
        {
            // ШАГ 1: Проверяем, есть ли результат в кеше
            if (memo.ContainsKey(amount))
            {
                return memo[amount];
            }

            // ШАГ 2: Вычисляем базовый случай
            if (amount == 0)
            {
                // Для суммы 0 монеты не нужны
                return 0;
            }

            // ШАГ 3: Если сумма отрицательна — решения нет
            if (amount < 0)
            {
                // Возвращаем "бесконечность"
                return int.MaxValue;
            }

            // ШАГ 4: Инициализируем результат максимальным значением
            int minCoins = int.MaxValue;

            // ШАГ 5: Пробуем каждую монету
            foreach (int coin in coins)
            {
                // Проверяем, можем ли использовать эту монету
                if (coin <= amount)
                {
                    // Рекурсивно решаем для оставшейся суммы
                    int result = Solve(amount - coin);
                    
                    // Если решение существует (не бесконечность)
                    if (result != int.MaxValue)
                    {
                        // Обновляем минимум: +1 за текущую монету
                        minCoins = Math.Min(minCoins, result + 1);
                    }
                }
            }

            // ШАГ 6: Сохраняем результат в кеш
            memo[amount] = minCoins;

            // ШАГ 7: Возвращаем результат
            return minCoins;
        }

        public int CacheSize => memo.Count;
    }

    static void Main()
    {
        // Тестовые данные
        int[] coins = { 1, 3, 4 };
        int amount = 6;

        Console.WriteLine("=== Задача размена монет (мемоизация) ===\n");
        Console.WriteLine($"Доступные монеты: [{string.Join(", ", coins)}]");
        Console.WriteLine($"Требуемая сумма: {amount}\n");

        var solver = new CoinChangeSolver(coins);

        var stopwatch = Stopwatch.StartNew();
        int minCoins = solver.Solve(amount);
        stopwatch.Stop();

        Console.WriteLine($"Минимум монет: {minCoins}");
        Console.WriteLine($"Размер кеша: {solver.CacheSize}");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");
        Console.WriteLine($"\nОбъяснение:");
        Console.WriteLine($"Жадный подход: 4 + 1 + 1 = {3} монеты");
        Console.WriteLine($"DP подход:     3 + 3 = {2} монеты ✓");
    }
}
```


### 4.3 Вариант 2: Табуляция для размена монет

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;

class CoinChangeTabulation
{
    /// <summary>
    /// Вычисление минимума монет с табуляцией
    /// Возвращает минимальное количество монет или -1 если решения нет
    /// </summary>
    static int MinCoinChange(int[] coins, int amount)
    {
        // ШАГ 1: Создаём таблицу DP
        // dp[i] = минимальное количество монет для суммы i
        int[] dp = new int[amount + 1];

        // ШАГ 2: Инициализируем таблицу
        // Начально все значения = максимум (кроме 0)
        for (int i = 1; i <= amount; i++)
        {
            // Устанавливаем максимальное значение
            // (оно указывает, что решение пока не найдено)
            dp[i] = int.MaxValue;
        }

        // ШАГ 3: Базовый случай
        // Для суммы 0 монеты не нужны
        dp[0] = 0;

        // ШАГ 4: Заполняем таблицу итеративно
        // Для каждой суммы от 1 до amount
        for (int i = 1; i <= amount; i++)
        {
            // Пробуем каждую монету
            foreach (int coin in coins)
            {
                // Проверяем, можно ли использовать эту монету
                if (coin <= i && dp[i - coin] != int.MaxValue)
                {
                    // Обновляем минимум
                    // dp[i] = минимум(dp[i], dp[i - coin] + 1)
                    dp[i] = Math.Min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        // ШАГ 5: Возвращаем результат
        // Если dp[amount] остался максимальным, решения нет
        return dp[amount] == int.MaxValue ? -1 : dp[amount];
    }

    /// <summary>
    /// Восстановление самих монет (не только количества)
    /// </summary>
    static List<int> GetCoins(int[] coins, int amount)
    {
        // Создаём таблицу DP
        int[] dp = new int[amount + 1];
        
        // Таблица для отслеживания выбранной монеты
        int[] parent = new int[amount + 1];

        // Инициализируем
        for (int i = 1; i <= amount; i++)
            dp[i] = int.MaxValue;

        dp[0] = 0;

        // Заполняем таблицу и отслеживаем выбранные монеты
        for (int i = 1; i <= amount; i++)
        {
            foreach (int coin in coins)
            {
                if (coin <= i && dp[i - coin] != int.MaxValue && dp[i - coin] + 1 < dp[i])
                {
                    // Обновляем количество монет
                    dp[i] = dp[i - coin] + 1;
                    
                    // Сохраняем выбранную монету
                    // Позже используем это для восстановления пути
                    parent[i] = coin;
                }
            }
        }

        // Восстанавливаем монеты, двигаясь назад
        var result = new List<int>();
        
        // Начинаем с требуемой суммы
        int current = amount;
        
        while (current > 0)
        {
            // Берём монету, которая была выбрана для этой суммы
            int coin = parent[current];
            
            // Добавляем в результат
            result.Add(coin);
            
            // Переходим к остатку
            current -= coin;
        }

        return result;
    }

    static void Main()
    {
        // Тестовые данные
        int[] coins = { 1, 3, 4 };
        int amount = 6;

        Console.WriteLine("=== Задача размена монет (табуляция) ===\n");
        Console.WriteLine($"Доступные монеты: [{string.Join(", ", coins)}]");
        Console.WriteLine($"Требуемая сумма: {amount}\n");

        var stopwatch = Stopwatch.StartNew();

        int minCoins = MinCoinChange(coins, amount);
        var selectedCoins = GetCoins(coins, amount);

        stopwatch.Stop();

        Console.WriteLine($"Минимум монет: {minCoins}");
        Console.WriteLine($"Выбранные монеты: {string.Join(" + ", selectedCoins)}");
        Console.WriteLine($"Проверка: {string.Join(" + ", selectedCoins)} = {string.Join(" + ", selectedCoins).Split('+').Length} монет");
        Console.WriteLine($"Время выполнения: {stopwatch.ElapsedMilliseconds} мс");
    }
}
```

**Вывод программы:**

```
=== Задача размена монет (табуляция) ===

Доступные монеты: [1, 3, 4]
Требуемая сумма: 6

Минимум монет: 2
Выбранные монеты: 3 + 3
Время выполнения: 0 мс
```


