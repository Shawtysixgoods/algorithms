## ТАБЛИЦА 1: БЫСТРОЕ СРАВНЕНИЕ ВСЕХ 7 АЛГОРИТМОВ

| Алгоритм | Лучший случай | Средний случай | Худший случай | Память | Стабильность | In-place | Когда использовать |
|----------|--------------|--------------|--------------|--------|--------------|---------|-------------------|
| **Bubble Sort** | O(n) Линейная | O(n²) Квадратичная | O(n²) Квадратичная | O(1) Константная | ✓ Да | ✓ Да | Только обучение, очень маленькие массивы |
| **Heap Sort** | O(n log n) Линеаримическая | O(n log n) Линеаримическая | O(n log n) Линеаримическая | O(1) Константная | ✗ Нет | ✓ Да | Embedded, мало памяти, приоритетные очереди |
| **Insertion Sort** | O(n) Линейная | O(n²) Квадратичная | O(n²) Квадратичная | O(1) Константная | ✓ Да | ✓ Да | Маленькие массивы (<50), почти отсортированные данные |
| **Merge Sort** | O(n log n) Линеаримическая | O(n log n) Линеаримическая | O(n log n) Линеаримическая | O(n) Линейная | ✓ Да | ✗ Нет | Гарантированное O(n log n), стабильность, большие данные |
| **Quick Sort** | O(n log n) Линеаримическая | O(n log n) Линеаримическая | O(n²) Квадратичная | O(log n) Логарифмическая | ✗ Нет | ✓ Да | Максимальная скорость на практике, стандарт везде |
| **Selection Sort** | O(n²) Квадратичная | O(n²) Квадратичная | O(n²) Квадратичная | O(1) Константная | ✗ Нет | ✓ Да | Минимизировать обмены, очень редко используется |
| **Shell Sort** | O(n log n)* | O(n^1.25) или O(n^1.5)* | O(n²) Квадратичная | O(1) Константная | ✗ Нет | ✓ Да | Средние массивы (1K-10K), без рекурсии, компактная память |

*Shell Sort зависит от выбранной gap-последовательности

---

## ТАБЛИЦА 2: КЛАССИФИКАЦИЯ ВРЕМЕННОЙ СЛОЖНОСТИ

| O-нотация | Название класса | Описание | n=100 | n=1,000 | n=10,000 | Практика |
|-----------|-----------------|---------|-------|---------|----------|----------|
| **O(1)** | **Константная** | Время не зависит от размера входа | 1 операция | 1 операция | 1 операция | Доступ по индексу, простые операции |
| **O(log n)** | **Логарифмическая** | Размер задачи уменьшается в 2 раза на каждом шаге | ~7 операций | ~10 операций | ~13 операций | Бинарный поиск, сбалансированные деревья |
| **O(n)** | **Линейная** | Один проход по всем n элементам | 100 операций | 1,000 операций | 10,000 операций | Один цикл, поиск линейный |
| **O(n log n)** | **Линеаримическая** | Комбинация линейной и логарифмической | ~700 операций | ~10,000 операций | ~130,000 операций | Merge Sort, Quick Sort, Heap Sort |
| **O(n²)** | **Квадратичная** | Вложенные циклы, медленный рост | 10,000 операций | 1,000,000 операций | 100,000,000 операций | Bubble Sort, Insertion Sort, Selection Sort |
| **O(n³)** | **Кубическая** | Три вложенных цикла | 1,000,000 операций | 1,000,000,000 операций | 1,000,000,000,000 операций | Наивное перемножение матриц |

---

## ТАБЛИЦА 3: ДЕТАЛЬНОЕ ОПИСАНИЕ КАЖДОГО АЛГОРИТМА

### BUBBLE SORT (ПУЗЫРЬКОВАЯ СОРТИРОВКА)

| Аспект | Описание |
|--------|----------|
| **Как работает** | Проходит по массиву, сравнивает соседние элементы, меняет местами если они в неправильном порядке. После каждого прохода самый крупный элемент "всплывает" в конец. Повторяет пока не будет сделано полного прохода без обменов. |
| **Пример прохода** | Массив: [5, 3, 8, 1] → [3, 5, 1, 8] → [3, 1, 5, 8] → [1, 3, 5, 8] ✓ |
| **Лучший случай** | O(n) Линейная — если добавить флаг `swapped`, то отсортированный массив сортируется за один проход. |
| **Средний случай** | O(n²) Квадратичная — каждый проход требует все больше сравнений и обменов. |
| **Худший случай** | O(n²) Квадратичная — массив в обратном порядке требует максимальное число операций. |
| **Память** | O(1) Константная — только несколько переменных для флагов и счетчиков, работает in-place. |
| **Стабильность** | ✓ Да — никогда не меняет порядок равных элементов. |
| **Когда НЕ использовать** | Массивы больше 100 элементов — время работы становится неприемлемо. |
| **Трюк** | Добавьте флаг: если ни одного обмена → выходите раньше! |
| **Реальные применения** | Только в учебных целях и демонстрациях алгоритмов. |

### INSERTION SORT (СОРТИРОВКА ВСТАВКАМИ)

| Аспект | Описание |
|--------|----------|
| **Как работает** | Делит массив на отсортированную (слева) и неотсортированную (справа) части. Берет первый элемент из неотсортированной, находит его место в отсортированной через линейный поиск, вставляет сдвигая остальные. |
| **Пример прохода** | [5 \| 3, 8, 1] → [3, 5 \| 8, 1] → [3, 5, 8 \| 1] → [1, 3, 5, 8] |
| **Лучший случай** | O(n) Линейная — отсортированный массив: каждый элемент уже на месте, только сравнения. |
| **Средний случай** | O(n²) Квадратичная — нужно искать место каждому элементу в отсортированной части. |
| **Худший случай** | O(n²) Квадратичная — массив в обратном порядке: каждый ищется в полностью отсортированной части. |
| **Память** | O(1) Константная — in-place, сдвигает элементы в том же массиве. |
| **Стабильность** | ✓ Да — никогда не меняет порядок, равные остаются на местах. |
| **Когда использовать** | Маленькие массивы (< 50 элементов), почти отсортированные данные, частая вставка новых элементов. |
| **Трюк** | Используйте для добавления новых элементов онлайн — очень быстро! |
| **Реальные применения** | Часть алгоритма Timsort (Python, Java), сортировка на лету при поступлении новых данных. |

### SELECTION SORT (СОРТИРОВКА ВЫБОРОМ)

| Аспект | Описание |
|--------|----------|
| **Как работает** | На каждом шаге ищет минимальный элемент в неотсортированной части массива, меняет его местами с первым элементом этой части. Постепенно строит отсортированный префикс. |
| **Пример прохода** | [5, 3, 8, 1] → найден 1, обмен → [1, 3, 8, 5] → найден 3, уже на месте → [1, 3, 8, 5] → найден 5, обмен → [1, 3, 5, 8] |
| **Лучший случай** | O(n²) Квадратичная — даже отсортированный массив требует n²/2 сравнений! |
| **Средний случай** | O(n²) Квадратичная — всегда ищет минимум в каждой подчасти. |
| **Худший случай** | O(n²) Квадратичная — все три случая одинаковые, очень предсказуемо. |
| **Память** | O(1) Константная — in-place, только счетчики. |
| **Стабильность** | ✗ Нет — обмены нарушают порядок равных элементов. |
| **Когда использовать** | Специфический случай: если операции обмена очень дорогие (работа с памятью EEPROM). Ровно n обменов — минимально! |
| **Особенность** | Всегда делает ровно n-1 обменов, но n²/2 сравнений — компромисс. |
| **Реальные применения** | Редко в производстве, но полезен в некоторых встроенных системах. |

### QUICK SORT (БЫСТРАЯ СОРТИРОВКА)

| Аспект | Описание |
|--------|----------|
| **Как работает** | Выбирает опорный элемент (pivot), разделяет массив на три части: меньше pivot, равно pivot, больше pivot. Рекурсивно сортирует левую и правую части. Все быстро работает если pivot близко к медиане. |
| **Пример прохода** | [5, 3, 8, 1] → pivot=3 → [1, 3] [5, 8] → [1] [3] [5] [8] ✓ |
| **Лучший случай** | O(n log n) Линеаримическая — pivot всегда делит пополам, глубина рекурсии log n. |
| **Средний случай** | O(n log n) Линеаримическая — при случайном pivot или рандомизации. |
| **Худший случай** | O(n²) Квадратичная — если pivot всегда минимум или максимум (например, первый элемент в отсортированном массиве). |
| **Память** | O(log n) Логарифмическая — на стеке рекурсии в среднем (O(n) в худшем). |
| **Стабильность** | ✗ Нет — разделение может переставить равные элементы. |
| **Когда использовать** | Практически ВСЕГДА для больших массивов! Самый быстрый в реальности, используется везде. |
| **Трюк** | Выбирайте pivot СЛУЧАЙНО или медиану-из-трех → избегаете худшего случая! |
| **Реальные применения** | std::sort (C++), Arrays.sort (Java), Introsort (гибрид). Стандарт во всех языках. |

### MERGE SORT (СОРТИРОВКА СЛИЯНИЕМ)

| Аспект | Описание |
|--------|----------|
| **Как работает** | Рекурсивно делит массив пополам до одиночных элементов (они уже "отсортированы"). Затем "сливает" две отсортированные половины в один массив, всегда сравнивая первые элементы каждой половины и беря меньший. |
| **Пример прохода** | [5, 3, 8, 1] → [5, 3] [8, 1] → [3, 5] [1, 8] → [1, 3, 5, 8] |
| **Лучший случай** | O(n log n) Линеаримическая — даже отсортированный массив требует всех операций слияния. |
| **Средний случай** | O(n log n) Линеаримическая — всегда глубина log n, на каждом уровне n операций. |
| **Худший случай** | O(n log n) Линеаримическая — худший = средний = лучший! Полностью предсказуем! |
| **Память** | O(n) Линейная — требует дополнительного массива для слияния. Критический недостаток! |
| **Стабильность** | ✓ Да — слияние сохраняет порядок равных элементов. |
| **Когда использовать** | Когда нужна ГАРАНТИЯ O(n log n) (системы реального времени, нельзя рисковать). Большие данные, нужна стабильность. |
| **Особенность** | Единственный алгоритм с гарантированным O(n log n) — ни лучше, ни хуже! |
| **Реальные применения** | Python sorted() (Timsort), Java Collections.sort() для Objects, внешняя сортировка файлов. |

### HEAP SORT (ПИРАМИДАЛЬНАЯ СОРТИРОВКА)

| Аспект | Описание |
|--------|----------|
| **Как работает** | Строит структуру Max-Heap (бинарная куча), где каждый родитель ≥ своих детей. Это занимает O(n). Затем n раз извлекает максимальный элемент (корень) и ставит в конец, перестраивая кучу для оставшейся части. |
| **Пример прохода** | [5, 3, 8, 1] → Heap: [8, 3, 5, 1] → извлечение 8 → [5, 3, 1] → извлечение 5 → [3, 1] → извлечение 3 → [1] → [1, 3, 5, 8] |
| **Лучший случай** | O(n log n) Линеаримическая — O(n) на построение + O(n log n) на извлечение. |
| **Средний случай** | O(n log n) Линеаримическая — средний = лучший = худший! |
| **Худший случай** | O(n log n) Линеаримическая — гарантированное время всегда! |
| **Память** | O(1) Константная — in-place, работает в самом массиве. |
| **Стабильность** | ✗ Нет — извлечение элементов нарушает порядок равных. |
| **Когда использовать** | Embedded системы, мобильные устройства с очень ограниченной памятью. Гарантированное O(n log n) без доп. памяти. |
| **Особенность** | Используется для реализации приоритетных очередей! |
| **Реальные применения** | Системы реального времени, embedded, приоритетные очереди, когда память ценнее скорости. |

### SHELL SORT (СОРТИРОВКА ШЕЛЛА)

| Аспект | Описание |
|--------|----------|
| **Как работает** | Обобщение сортировки вставками с переменным шагом (gap). Сначала сортирует элементы на расстоянии gap, потом gap уменьшается (например gap/3), повторяется. На последней итерации gap=1 это обычная insertion sort. Эффективность зависит от выбора gap-последовательности. |
| **Пример прохода** | [5, 3, 8, 1] gap=2: [3, 1, 8, 5] gap=1: [1, 3, 5, 8] |
| **Лучший случай** | O(n log n) Линеаримическая — при оптимальной gap-последовательности. |
| **Средний случай** | O(n^1.25) или O(n^1.5) — зависит от gap-последовательности (Knuth, Hibbard, Sedgewick). |
| **Худший случай** | O(n²) Квадратичная — при плохой gap-последовательности (например, степени 2). |
| **Память** | O(1) Константная — in-place, без рекурсии! |
| **Стабильность** | ✗ Нет — межшаговые сравнения нарушают порядок. |
| **Когда использовать** | Средние массивы (1000-10000 элементов), когда рекурсия запрещена (embedded, ограниченный стек). |
| **Трюк** | Используйте хорошую gap-последовательность: Knuth (3k+1), Hibbard (2^k-1), Sedgewick. |
| **Реальные применения** | Встроенные системы, некоторые компилятары как альтернатива Quick Sort. |

---

## ТАБЛИЦА 4: КОД КАЖДОГО АЛГОРИТМА С КОММЕНТАРИЯМИ

### BUBBLE SORT

```python
def bubble_sort(arr):
    """
    Пузырьковая сортировка: сравнивает соседние элементы, 
    меняет если в неправильном порядке. Крупные "всплывают" вверх.
    """
    n = len(arr)  # Получаем длину массива
    
    # Внешний цикл: проходим по массиву
    for i in range(n):
        swapped = False  # Флаг для отслеживания обменов
        
        # Внутренний цикл: с каждым проходом на один элемент меньше
        # Потому что последние элементы уже на месте
        for j in range(0, n-i-1):
            # Если левый элемент больше правого
            if arr[j] > arr[j+1]:
                # Меняем их местами
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        
        # Если на проходе не было ни одного обмена
        if not swapped:
            # Массив уже отсортирован, выходим раньше
            break
    
    return arr
```

### INSERTION SORT

```python
def insertion_sort(arr):
    """
    Сортировка вставками: берет элементы по одному и вставляет 
    их на правильное место в уже отсортированную часть.
    """
    # Начинаем со второго элемента (индекс 1)
    for i in range(1, len(arr)):
        key = arr[i]  # Текущий элемент для вставки
        j = i - 1     # Индекс для просмотра отсортированной части
        
        # Смещаем элементы отсортированной части вправо,
        # пока не найдем правильное место для key
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]  # Смещаем элемент вправо
            j -= 1             # Переходим к предыдущему элементу
        
        # Вставляем key на найденную позицию
        arr[j+1] = key
    
    return arr
```

### SELECTION SORT

```python
def selection_sort(arr):
    """
    Сортировка выбором: на каждом шаге находит минимальный элемент 
    и кладет его в начало неотсортированной части.
    """
    n = len(arr)
    
    # Проходим по каждой позиции
    for i in range(n):
        min_idx = i  # Предполагаем текущий элемент минимальным
        
        # Ищем минимальный элемент в оставшейся части
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                # Нашли меньший элемент, обновляем индекс минимума
                min_idx = j
        
        # Если минимальный элемент не на текущей позиции
        if min_idx != i:
            # Меняем его с текущим элементом
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```

### QUICK SORT

```python
def quick_sort(arr):
    """
    Быстрая сортировка: разделяй и властвуй.
    Выбирает pivot, делит массив на меньше/равно/больше,
    рекурсивно сортирует части.
    """
    # Базовый случай: массив из 0 или 1 элемента уже отсортирован
    if len(arr) <= 1:
        return arr
    
    # Выбираем опорный элемент (pivot) - середину массива
    pivot = arr[len(arr) // 2]
    
    # Разделяем массив на три части используя list comprehension
    left = [x for x in arr if x < pivot]      # Все меньше pivot
    middle = [x for x in arr if x == pivot]   # Все равные pivot
    right = [x for x in arr if x > pivot]     # Все больше pivot
    
    # Рекурсивно сортируем левую и правую части, объединяем результат
    return quick_sort(left) + middle + quick_sort(right)


# Более оптимальная in-place версия:
def quick_sort_inplace(arr, low=0, high=None):
    """
    Быстрая сортировка in-place: работает с тем же массивом, 
    не создает новые списки (экономит память).
    """
    if high is None:
        high = len(arr) - 1
    
    # Базовый случай: подмассив из одного элемента
    if low < high:
        # Получаем позицию pivot после разделения
        pi = partition(arr, low, high)
        
        # Рекурсивно сортируем левую часть
        quick_sort_inplace(arr, low, pi - 1)
        # Рекурсивно сортируем правую часть
        quick_sort_inplace(arr, pi + 1, high)
    
    return arr


def partition(arr, low, high):
    """
    Вспомогательная функция: разделяет массив относительно pivot.
    Возвращает индекс pivot после разделения.
    """
    # Выбираем pivot (можно улучшить: случайный выбор или медиана)
    pivot = arr[high]
    
    # Индекс для отслеживания позиции
    i = low - 1
    
    # Проходим по элементам
    for j in range(low, high):
        # Если элемент меньше pivot
        if arr[j] < pivot:
            i += 1
            # Меняем местами
            arr[i], arr[j] = arr[j], arr[i]
    
    # Ставим pivot на его финальную позицию
    arr[i+1], arr[high] = arr[high], arr[i+1]
    
    return i + 1
```

### MERGE SORT

```python
def merge_sort(arr):
    """
    Сортировка слиянием: разделяй и властвуй.
    Делит массив пополам, рекурсивно сортирует, затем сливает.
    """
    # Базовый случай: массив из одного элемента уже отсортирован
    if len(arr) <= 1:
        return arr
    
    # Находим середину для разделения
    middle = len(arr) // 2
    
    # Рекурсивно сортируем левую половину
    left_half = merge_sort(arr[:middle])
    
    # Рекурсивно сортируем правую половину
    right_half = merge_sort(arr[middle:])
    
    # Сливаем две отсортированные половины
    return merge(left_half, right_half)


def merge(left, right):
    """
    Вспомогательная функция: сливает две отсортированные части
    в один отсортированный массив.
    """
    result = []  # Результирующий массив
    i = j = 0    # Индексы для левой и правой части
    
    # Сравниваем элементы из левой и правой части
    while i < len(left) and j < len(right):
        # Если элемент из левой части меньше
        if left[i] < right[j]:
            # Добавляем его в результат и переходим к следующему
            result.append(left[i])
            i += 1
        else:
            # Иначе добавляем элемент из правой части
            result.append(right[j])
            j += 1
    
    # Добавляем оставшиеся элементы из левой части (если они есть)
    result.extend(left[i:])
    
    # Добавляем оставшиеся элементы из правой части (если они есть)
    result.extend(right[j:])
    
    return result
```

### HEAP SORT

```python
def heap_sort(arr):
    """
    Пирамидальная сортировка: строит кучу (heap), 
    затем многократно извлекает максимум.
    """
    n = len(arr)
    
    # Строим Max-Heap (максимальная куча)
    # Начинаем с последнего не-листового узла
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Извлекаем элементы по одному из кучи
    for i in range(n-1, 0, -1):
        # Максимальный элемент (корень) ставим в конец
        arr[0], arr[i] = arr[i], arr[0]
        
        # Перестраиваем кучу для оставшейся части
        heapify(arr, i, 0)
    
    return arr


def heapify(arr, n, i):
    """
    Вспомогательная функция: перестраивает кучу,
    обеспечивая свойство Max-Heap.
    """
    largest = i           # Изначально считаем корень (индекс i) максимальным
    left = 2 * i + 1      # Индекс левого потомка
    right = 2 * i + 2     # Индекс правого потомка
    
    # Если левый потомок существует И больше корня
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    # Если правый потомок существует И больше текущего максимума
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    # Если максимум не корень (нарушение свойства кучи)
    if largest != i:
        # Меняем корень с максимальным потомком
        arr[i], arr[largest] = arr[largest], arr[i]
        
        # Рекурсивно перестраиваем поддерево
        heapify(arr, n, largest)
```

### SHELL SORT

```python
def shell_sort(arr):
    """
    Сортировка Шелла: обобщенная сортировка вставками
    с переменным шагом (gap). Сначала большие шаги, потом уменьшаем.
    """
    n = len(arr)
    gap = n // 2  # Начинаем с половины длины массива
    
    # Повторяем пока шаг не станет нулевым
    while gap > 0:
        # Начинаем с элемента на позиции gap
        for i in range(gap, n):
            temp = arr[i]  # Текущий элемент
            j = i
            
            # Сравниваем с элементом на расстоянии gap
            # и смещаем его вправо если он больше
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]  # Смещаем элемент вправо на gap позиций
                j -= gap               # Переходим к следующему сравнению
            
            # Ставим текущий элемент на его место
            arr[j] = temp
        
        # Уменьшаем шаг на 3 (gap = gap // 3)
        gap //= 3
    
    return arr
```

---

## ТАБЛИЦА 5: ДЕРЕВО ВЫБОРА

```
╔═══════════════════════════════════════════════════════════════╗
║              ВЫБЕРИ СВОЙ АЛГОРИТМ СОРТИРОВКИ                 ║
╚═══════════════════════════════════════════════════════════════╝

                        ┌─ КАКОЙ РАЗМЕР МАССИВА? ─┐
                        │                          │
                    ┌───┴──┬─────────────┬────────┬─┴──────┐
                    │      │             │        │         │
                 <10    10-50          50-1000  1K-10K   >10K
                  │       │              │        │        │
             [Bubble]  [Insert]    [Insert/Heap] │   [Quick/Merge]
                  │       │              │        │        │
                  └───┬───┴──────┬───────┴───┬────┴──┬─────┘
                      │         │            │       │
          ┌─ СТАБИЛЬНОСТЬ НУЖНА? ─┐          │    [Shell Sort]
          │                       │          │
         ДА                       НЕТ         │
         │                        │          │
    [Merge Sort]      ┌──────────┴┴──────┬──┴─────┐
    [Insertion]       │                  │        │
                  [Quick Sort]    [Heap Sort] [Merge Sort]
                  (если памяти    (если памяти (если памяти
                   хватает)        мало)       хватает)

═════════════════════════════════════════════════════════════════

         КОД ПРИМЕРОВ ИСПОЛЬЗОВАНИЯ КАЖДОГО АЛГОРИТМА

```

---

## ТАБЛИЦА 6: ПРАКТИЧЕСКИЕ ПРИМЕРЫ

### Пример 1: Сортировка списка студентов

```python
# Студент с именем и оценкой
students = [
    ("Иван", 85),
    ("Мария", 92),
    ("Петр", 78),
    ("Анна", 92),  # Равная оценка с Марией
    ("Олег", 88)
]

# ВАРИАНТ 1: Нужна СТАБИЛЬНОСТЬ (сохранить порядок студентов с одинаковой оценкой)
# → Используем Merge Sort
def merge_sort_students(students):
    # Весь код как раньше, но сравниваем по оценке (второй элемент кортежа)
    if len(students) <= 1:
        return students
    
    middle = len(students) // 2
    left = merge_sort_students(students[:middle])
    right = merge_sort_students(students[middle:])
    
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        # Сравниваем оценки (второй элемент)
        if left[i][1] < right[j][1]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Результат: порядок Марии и Анны сохранен (Мария первая, потом Анна)
sorted_students = merge_sort_students(students)

# ВАРИАНТ 2: Стабильность не нужна, нужна максимальная скорость
# → Используем Quick Sort
def quick_sort_students(students):
    if len(students) <= 1:
        return students
    
    pivot = students[len(students) // 2]
    
    left = [s for s in students if s[1] < pivot[1]]
    middle = [s for s in students if s[1] == pivot[1]]
    right = [s for s in students if s[1] > pivot[1]]
    
    return quick_sort_students(left) + middle + quick_sort_students(right)
```

### Пример 2: Сортировка миллионов чисел на мобильном

```python
import sys

# На мобильном памяти ограничено!
# Массив из 1 млн элементов занимает ~4 МБ
big_array = list(range(1000000, 0, -1))  # 1 млн чисел в обратном порядке

print(f"Размер памяти массива: {sys.getsizeof(big_array) / (1024*1024):.2f} МБ")

# ВАРИАНТ 1: Если нужно гарантированное O(n log n) и стабильность
# → Merge Sort (требует дополнительно 1 млн элементов в памяти)
sorted_array = merge_sort(big_array)  # Требует ~8 МБ памяти всего

# ВАРИАНТ 2: Если памяти критически мало
# → Heap Sort (работает in-place, требует только текущий массив)
sorted_array = heap_sort(big_array)  # Требует ~4 МБ памяти всего

# ВАРИАНТ 3: Быстро и с минимальной памятью
# → Shell Sort (in-place, быстро на средних массивах)
sorted_array = shell_sort(big_array)  # Требует ~4 МБ памяти всего
```

### Пример 3: Постоянно поступающие новые данные (реал-тайм)

```python
# Данные приходят по одному элементу в реальном времени
incoming_data = [5, 3, 8, 1, 9, 2, 7, 4]

# Вариант: используем Insertion Sort для постоянного обновления
sorted_list = []

for new_item in incoming_data:
    # Добавляем новый элемент и сразу его вставляем на место
    sorted_list.append(new_item)
    
    # Используем Insertion Sort только для позиции нового элемента
    # Это очень быстро, так как остальные элементы уже отсортированы
    i = len(sorted_list) - 1
    while i > 0 and sorted_list[i-1] > sorted_list[i]:
        sorted_list[i-1], sorted_list[i] = sorted_list[i], sorted_list[i-1]
        i -= 1
    
    print(f"После добавления {new_item}: {sorted_list}")

# Результат: [1, 2, 3, 4, 5, 7, 8, 9]
```

### Пример 4: Сравнение скорости на практике

```python
import time
import random

# Создаем большой массив случайных чисел
size = 10000
test_array = [random.randint(1, 100000) for _ in range(size)]

# Сравним разные алгоритмы

# Bubble Sort - медленно!
start = time.time()
bubble_sort(test_array.copy())
bubble_time = time.time() - start
print(f"Bubble Sort: {bubble_time:.4f} сек")

# Insertion Sort - быстрее для такого размера
start = time.time()
insertion_sort(test_array.copy())
insert_time = time.time() - start
print(f"Insertion Sort: {insert_time:.4f} сек")

# Quick Sort - очень быстро!
start = time.time()
quick_sort(test_array.copy())
quick_time = time.time() - start
print(f"Quick Sort: {quick_time:.4f} сек")

# Merge Sort - гарантированно быстро
start = time.time()
merge_sort(test_array.copy())
merge_time = time.time() - start
print(f"Merge Sort: {merge_time:.4f} сек")

# Heap Sort - быстро, экономит память
start = time.time()
heap_sort(test_array.copy())
heap_time = time.time() - start
print(f"Heap Sort: {heap_time:.4f} сек")

# Shell Sort - хороший компромисс
start = time.time()
shell_sort(test_array.copy())
shell_time = time.time() - start
print(f"Shell Sort: {shell_time:.4f} сек")

print(f"\nСамый быстрый: Quick Sort ({quick_time:.4f} сек)")
print(f"Соотношение Bubble/Quick: {bubble_time/quick_time:.1f}x медленнее")
```

---

## ТАБЛИЦА 7: ЧЕКЛИСТ ДЛЯ ВЫБОРА

```
ОТВЕЧАЕШЬ НА ВОПРОСЫ:

□ Размер массива < 50?
  ДА  → Insertion Sort (быстро на маленьких)
  НЕТ → следующий вопрос

□ Стабильность критична?
  ДА  → Merge Sort (гарантированная стабильность и O(n log n))
  НЕТ → следующий вопрос

□ Память ограничена?
  ДА  → Heap Sort или Shell Sort (O(1) памяти)
  НЕТ → следующий вопрос

□ Нужна максимальная скорость?
  ДА  → Quick Sort (самый быстрый на практике)
  НЕТ → следующий вопрос

ИТОГОВЫЙ ВЫБОР:

• Маленький + быстро         → Insertion Sort
• Маленький + точный         → Bubble Sort (только обучение!)
• Большой + стабильность     → Merge Sort
• Большой + мало памяти      → Heap Sort
• Большой + максимум скорости → Quick Sort
• Большой + нет рекурсии     → Shell Sort
• Очень большой + любое      → Quick Sort или Merge Sort
```

---

## ТАБЛИЦА 8: ТИПИЧНЫЕ ОШИБКИ И КАК ИХ ИЗБЕЖАТЬ

| Ошибка | Что происходит | Как избежать |
|--------|----------------|-------------|
| Используешь Bubble Sort для 1 млн элементов | Программа зависает на часы | Выбери Quick Sort или Merge Sort |
| Выбираешь первый элемент как pivot в Quick Sort на отсортированных данных | О(n²) сложность вместо O(n log n) | Используй random pivot или медиану-из-трех |
| Используешь Merge Sort на мобильном с 256 МБ памяти | Программа падает: нет памяти для временного массива | Используй Heap Sort или Shell Sort (in-place) |
| Забыл про стабильность при сортировке объектов | Порядок равных объектов нарушен, логика сломана | Используй Merge Sort для стабильности |
| Используешь Selection Sort думая что это быстро | Медленно как черепаха | Selection Sort O(n²), используй Quick Sort |

---

ВСЕ! ТАБЛИЦА ГОТОВА!
