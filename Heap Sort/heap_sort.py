# Функция для превращения поддерева с корнем i в max-heap
# n - размер кучи (может быть меньше длины всего arr!)
# i - индекс корня поддерева, которое "чиним"
def heapify(arr, n, i):
    # 1. Находим Индексы
    largest = i      # Сначала считаем, что "корень" i и есть самый большой
    left = 2 * i + 1  # Индекс левого "ребенка"
    right = 2 * i + 2 # Индекс правого "ребенка"

    # 2. Ищем Реально Самого Большого среди i, left, right
    # Если левый ребенок существует (в пределах кучи n) И он больше текущего largest...
    if left < n and arr[left] > arr[largest]:
        largest = left # ...то левый ребенок становится кандидатом на "самого большого"

    # Если правый ребенок существует (в пределах кучи n) И он больше текущего largest...
    if right < n and arr[right] > arr[largest]:
        largest = right # ...то правый ребенок становится кандидатом (или перебивает левого)

    # 3. Если Самый Большой НЕ на месте i (т.е. один из детей больше родителя)
    if largest != i:
        # Меняем местами родителя (i) и самого большого ребенка (largest)
        arr[i], arr[largest] = arr[largest], arr[i]

        # 4. Рекурсивный Вызов для "Пострадавшего" Поддерева
        # После обмена, элемент, который был в i, теперь в largest.
        # Возможно, он нарушает свойство кучи НИЖЕ по дереву.
        # Поэтому рекурсивно вызываем heapify для поддерева с корнем largest.
        heapify(arr, n, largest)

# --- Основная функция сортировки ---
def heap_sort(arr):
    n = len(arr) # Размер всего массива

    # === Шаг 1: Построение Max-Heap ===
    # Мы начинаем с последнего узла, у которого МОГУТ быть дети.
    # Индекс последнего элемента n-1. Его родитель (n-1 - 1)//2 = n//2 - 1.
    # Идем СНИЗУ ВВЕРХ по всем родительским узлам (до корня, индекс 0).
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i) # Превращаем поддерево с корнем i в кучу
    # После этого цикла ВЕСЬ массив arr является Max-Heap.

    # === Шаг 2: Извлечение элементов и Сортировка ===
    # Мы будем n-1 раз извлекать максимум.
    # i будет идти от последнего индекса (n-1) вниз до 1.
    for i in range(n - 1, 0, -1):
        # 1. Меняем корень (arr[0], текущий максимум) с последним элементом
        #    в НЕОТСОРТИРОВАННОЙ части кучи (arr[i]).
        arr[i], arr[0] = arr[0], arr[i]
        # Теперь максимум arr[i] на своем финальном месте.

        # 2. "Уменьшаем" размер кучи (исключаем отсортированный arr[i])
        #    и восстанавливаем свойство Max-Heap для оставшихся элементов (от 0 до i-1).
        #    Новый корень (бывший arr[i]) скорее всего не на месте.
        heapify(arr, i, 0) # Вызываем heapify для корня (0) с новым размером кучи i.

# Пример:
numbers = [12, 11, 13, 5, 6, 7]
heap_sort(numbers) # Запускаем
print(numbers)     # Получаем: [5, 6, 7, 11, 12, 13]