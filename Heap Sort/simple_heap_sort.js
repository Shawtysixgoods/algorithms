// === ФУНКЦИЯ heapify - "ЧИНИТ" ПИРАМИДУ ===
// Представь, что у нас есть башня из кубиков. Эта функция проверяет:
// "Самый ли большой кубик стоит наверху?" И если нет - чинит это!
function heapify(arr, n, i) {
    // arr - это наша коробка со всеми кубиками
    // n - сколько кубиков мы сейчас проверяем (иногда не все!)
    // i - это номер кубика, с которого начинаем проверку

    // 1. НАЗНАЧАЕМ ГЛАВНОГО
    let largest = i;       
    // Говорим: "Пока что кубик номер i - самый большой из трёх"
    
    let left = 2 * i + 1;  
    // Это волшебная формула! Она говорит, где находится ЛЕВЫЙ ребёнок
    // Если папа стоит в позиции 0, то левый ребёнок в позиции 1
    // Если папа в позиции 1, то левый ребёнок в позиции 3. Всегда так!
    
    let right = 2 * i + 2; 
    // А это формула для ПРАВОГО ребёнка
    // Если папа в позиции 0, то правый ребёнок в позиции 2
    // Правый всегда на один шаг правее левого!

    // 2. ПРОВЕРЯЕМ ЛЕВОГО РЕБЁНКА
    if (left < n && arr[left] > arr[largest]) {
        // left < n - проверяем "А есть ли вообще левый ребёнок?"
        // (Может быть, мы уже в конце коробки!)
        
        // arr[left] > arr[largest] - смотрим: левый ребёнок БОЛЬШЕ папы?
        // Если ДА, то говорим: "Ага! Левый ребёнок самый большой!"
        
        largest = left; 
        // Запоминаем, что теперь левый - кандидат на "самого большого"
    }

    // 3. ПРОВЕРЯЕМ ПРАВОГО РЕБЁНКА
    if (right < n && arr[right] > arr[largest]) {
        // right < n - проверяем "А есть ли правый ребёнок?"
        
        // arr[right] > arr[largest] - правый ребёнок больше, чем тот,
        // кого мы считали самым большим (папа или левый брат)?
        
        largest = right; 
        // Если ДА, то правый становится новым "самым большим"!
    }

    // 4. МЕНЯЕМ МЕСТАМИ, ЕСЛИ НУЖНО
    if (largest !== i) {
        // largest !== i означает: "Самый большой - это НЕ папа!"
        // Один из детей оказался больше! Это неправильно для нашей башни!
        
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        // МЕНЯЕМ местами папу и самого большого ребёнка
        // Теперь большой кубик поднялся наверх, как и должно быть!

        // 5. ПРОВЕРЯЕМ ДАЛЬШЕ ВНИЗ
        heapify(arr, n, largest);
        // Подожди! Маленький кубик (который был папой) теперь спустился вниз
        // Возможно, там у НЕГО тоже есть дети, и он меньше их!
        // Поэтому мы снова вызываем эту же функцию, но уже для нового места
        // Это как спускать кубик по лестнице, пока он не найдёт своё место!
    }
    // Если largest === i, значит папа и так самый большой - ничего не делаем!
}

// === ГЛАВНАЯ ФУНКЦИЯ heapSort - СОРТИРУЕТ КУБИКИ ===
function heapSort(arr) {
    let n = arr.length; 
    // Считаем, сколько всего у нас кубиков в коробке

    // === ШАГ 1: СТРОИМ БОЛЬШУЮ ПИРАМИДУ ИЗ ВСЕХ КУБИКОВ ===
    
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        // Math.floor(n / 2) - 1 - это последний кубик, у которого ЕСТЬ дети
        // Почему? Потому что в нашей башне кубики внизу - это детки!
        // Мы начинаем проверять с ПОСЛЕДНЕГО ПАПЫ и идём назад к самой вершине
        // (Кубики в конце массива - это "листочки", у них детей нет)
        
        heapify(arr, n, i); 
        // Для каждого папы "чиним" его маленькую башенку
        // Идём от низа к верху, чтобы вся большая башня стала правильной!
    }
    // Теперь ВЕСЬ массив - это красивая пирамида!
    // Самый БОЛЬШОЙ кубик точно наверху (в позиции 0)!

    // === ШАГ 2: ВЫТАСКИВАЕМ КУБИКИ ПО ОДНОМУ ===
    
    for (let i = n - 1; i > 0; i--) {
        // i = n - 1 - начинаем с ПОСЛЕДНЕЙ позиции в коробке
        // Идём назад: i > 0 означает, что останавливаемся, когда остался 1 кубик
        
        // 1. ЗАБИРАЕМ САМЫЙ БОЛЬШОЙ КУБИК С ВЕРШИНЫ
        [arr[0], arr[i]] = [arr[i], arr[0]];
        // arr[0] - это вершина пирамиды, там ВСЕГДА самый большой кубик!
        // arr[i] - это последнее место в нашей рабочей части
        // Мы МЕНЯЕМ их местами:
        //   - Большой кубик уходит в конец (на своё финальное место!)
        //   - Последний кубик поднимается наверх (но он, скорее всего, маленький!)

        // 2. ЧИНИМ ПИРАМИДУ ДЛЯ ОСТАВШИХСЯ КУБИКОВ
        heapify(arr, i, 0);
        // arr - наша коробка
        // i - размер кучи УМЕНЬШИЛСЯ (мы же забрали один кубик в конец!)
        // 0 - чиним с самой вершины, потому что туда попал маленький кубик
        
        // После "починки" следующий по величине кубик окажется наверху!
        // И мы снова его заберём на следующем круге цикла!
    }
    // Когда цикл закончится, все кубики выстроены по порядку:
    // от самого маленького (в начале) до самого большого (в конце)!
}

// === ПРИМЕР РАБОТЫ ===
let numbers = [12, 11, 13, 5, 6, 7];
// Представь: у нас 6 кубиков с этими цифрами, они перемешаны

heapSort(numbers);
// Вызываем волшебную функцию - она их сортирует!

console.log(numbers); 
// Смотрим результат: [5, 6, 7, 11, 12, 13]
// Все кубики выстроились по порядку от маленького к большому!
