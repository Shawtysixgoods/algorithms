### Что такое пирамидальная сортировка?

Пирамидальная сортировка (Heap Sort) – это метод упорядочивания массива с использованием структуры данных «двоичная куча» (heap). Идея состоит в том, чтобы сначала «выстроить» кучу из элементов массива, а затем многократно извлекать из неё максимальный элемент (при сортировке по возрастанию) и помещать его в конец массива. В итоге мы получаем отсортированный список.

### Аналогия из жизни

Представьте, что вам нужно расставить тяжёлые коробки по массе в порядке возрастания. Вы можете свалить все коробки в одну «пирамиду» так, чтобы тяжёлые коробки оказались наверху. Затем вы берёте самую тяжёлую коробку с вершины (это максимум) и кладёте её в конец своего упорядоченного ряда. После этого «подправляете» пирамиду, чтобы следующая самая тяжёлая оказалась сверху, и снова убираете её в следующий конец ряда. Продолжаете, пока все коробки не встанут на свои места.

### Что такое Куча (Heap)? 
Представь себе дерево (как генеалогическое), но с особым правилом:
- Max-Heap (Макс-Куча): Любой "родитель" в этом дереве всегда больше или равен своим "детям". Это значит, что самый главный "босс" (самое большое число) всегда находится на самом верху, в корне дерева.
- Min-Heap (Мин-Куча): То же самое, но наоборот: родитель всегда меньше или равен детям. Самый "младший" (маленькое число) наверху.

### Как работает Пирамидальная Сортировка? (Два Главных Шага)

У нас есть наш беспорядочный список: [12, 11, 13, 5, 6, 7].
#### Шаг 1: Построй Кучу!
- Мы должны перестроить наш список так, чтобы он стал Max-Heap. То есть, чтобы самое большое число оказалось на первом месте (arr[0]), а для всех остальных элементов выполнялось правило "родитель >= дети".
- Это делается с помощью специальной процедуры heapify (о ней ниже), применяемой ко всем "родительским" узлам, начиная с самого нижнего.

#### Шаг 2: Разбирай Кучу и Сортируй!
- Теперь, когда у нас есть Max-Heap, мы знаем, что самый большой элемент находится в самом начале (arr[0]). Это его законное место... но в конце отсортированного списка!
Что делаем:
- Меняем местами самый большой элемент (arr[0]) с последним элементом в текущей (еще не отсортированной) части списка. Теперь самый большой элемент "зафиксирован" на своем финальном месте в конце.
- "Забываем" про этот последний элемент (уменьшаем размер рассматриваемой кучи на 1).
- На первом месте теперь стоит какой-то другой элемент (тот, что был последним). Он, скорее всего, нарушает правило кучи!
- Снова применяем heapify к самому первому элементу (arr[0]), чтобы восстановить свойство Max-Heap для оставшейся части списка.
- Повторяем: Снова меняем новый arr[0] (теперь это второй по величине элемент) с предпоследним элементом, "забываем" про предпоследний, восстанавливаем кучу для оставшихся... И так далее, пока вся куча не "разберется" в отсортированный список.

### Суть Пирамидальной Сортировки:
Преврати массив в "кучу" (max-heap), где самый большой элемент наверху.
Повторяй n-1 раз:
Поменяй верхний (самый большой) элемент с последним элементом кучи.
Уменьши размер кучи на 1 (игнорируй последний, он уже отсортирован).
Почини кучу (вызови heapify для верхушки), чтобы следующий по величине элемент снова всплыл наверх.
Это эффективный алгоритм сортировки (сравнимый по скорости с быстрой сортировкой и слиянием в среднем), и он сортирует "на месте", то есть не требует много дополнительной памяти (кроме как для рекурсии в heapify).

### Визуальная блок-схема

```md
          ┌─────────────┐
          │ Начать       │
          └─────────────┘
               │
   ┌────────────▼─────────────────┐
   │ Построить max-heap из массива│
   └──────────────────────────────┘
               │
   ┌────────────▼────────────────────────────────┐
   │ Меняем местами первый элемент (максимум)    │
   │ c последним неотсортированным элементом.    │
   └──────────────────────────────────────────────┘
               │
   ┌────────────▼─────────────────────────┐
   │ "Убираем" последний элемент из кучи, │
   │ уменьшаем её размер на 1            │
   └──────────────────────────────────────┘
               │
   ┌────────────▼────────────────────────────────────┐
   │ Восстанавливаем свойства max-heap ( heapify )   │
   │ для уменьшенной кучи                            │
   └──────────────────────────────────────────────────┘
               │
   ┌────────────▼────────────────┐
   │ Повторять, пока неотсортированные
   │ элементы в куче не закончатся  │
   └───────────────────────────────┘
               │
         ┌─────▼─────┐
         │ Конец      │
         └────────────┘

```

Вначале мы превращаем весь массив в кучу (max-heap), а затем многократно извлекаем максимум (верхушку кучи), ставим его в конец, «срезаем» кучу на один элемент и восстанавливаем её.