#include <iostream>
#include <vector> // используем динамический массив
using namespace std;

// Функция для превращения поддерева с корнем i в max-heap
// arr - вектор, n - размер кучи, i - индекс корня поддерева
void heapify(vector<int>& arr, int n, int i) {
    // 1. Находим Индексы
    int largest = i; // Сначала считаем, что корень i самый большой
    int left = 2 * i + 1;  // Индекс левого ребенка
    int right = 2 * i + 2; // Индекс правого ребенка

    // 2. Ищем Реально Самого Большого среди i, left, right
    if (left < n && arr[left] > arr[largest]) {
        largest = left; // Левый ребенок становится кандидатом на "самого большого"
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right; // Правый ребенок перебивает левого/родителя
    }

    // 3. Если Самый Большой НЕ на месте i
    if (largest != i) {
        swap(arr[i], arr[largest]); // Меняем местами родителя и самого большого ребенка
        // 4. Рекурсивно "чиним" поддерево с корнем largest
        heapify(arr, n, largest);
    }
}

// Основная функция сортировки
void heapSort(vector<int>& arr) {
    int n = arr.size();

    // === Шаг 1: Построение Max-Heap ===
    // Начинаем с последнего родительского узла (n/2 - 1) и идем к корню (0)
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i); // Превращаем поддерево с корнем i в кучу
    }

    // === Шаг 2: Извлечение элементов и сортировка ===
    // i идет от конца массива к началу
    for (int i = n - 1; i >= 1; i--) {
        // 1. Меняем корень (максимум) с последним элементом в куче
        swap(arr[0], arr[i]);
        // 2. "Уменьшаем" размер кучи, восстанавливаем свойство Max-Heap
        heapify(arr, i, 0); // i - новый размер кучи, корень - 0
    }
}

int main() {
    // Пример:
    vector<int> numbers = {12, 11, 13, 5, 6, 7};
    heapSort(numbers); // Запускаем
    // Выводим массив:
    cout << "Отсортированный массив: ";
    for (int num : numbers) cout << num << " ";
    cout << endl;
    return 0;
}
