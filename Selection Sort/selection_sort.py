def selection_sort(arr): # arr - твой список чисел, например [64, 25, 12, 22, 11]
    n = len(arr)         # n - сколько чисел в списке (здесь 5)

    # 1. Основной Проход (Внешний цикл)
    for i in range(n - 1):
        # Зачем? Этот цикл отвечает за то, на КАКОЕ МЕСТО (i) мы сейчас ищем число.
        # Мы ищем число для 0-го места, потом для 1-го, потом для 2-го и т.д.
        # Почему n-1? Когда мы поставим правильное число на предпоследнее место,
        # последнее оставшееся число автоматически будет самым большим и окажется на своем месте.
        # i - это индекс места, которое мы сейчас "заполняем" правильным числом (0, 1, 2, 3...).

        # 2. Поиск Самого Маленького (Начало)
        min_index = i
        # Зачем? Мы ПОКА НЕ ЗНАЕМ, где самое маленькое число.
        # Давайте ПРЕДПОЛОЖИМ, что самое маленькое число - это то, которое УЖЕ стоит
        # на том месте (i), куда мы ищем. Запомним его ИНДЕКС (местоположение).
        # min_index - это МЕСТО (индекс), где находится САМОЕ МАЛЕНЬКОЕ число из тех,
        # что мы УЖЕ проверили в неотсортированной части. Начинаем с i.

        # 3. Поиск Самого Маленького (Продолжение - Внутренний цикл)
        for j in range(i + 1, n):
            # Зачем? Чтобы ПРОСМОТРЕТЬ ОСТАВШИЕСЯ числа (справа от i) и найти ДЕЙСТВИТЕЛЬНО
            # самое маленькое среди них.
            # j - это индекс числа, которое мы СЕЙЧАС сравниваем с нашим текущим минимумом.
            # Почему range(i + 1, n)? Мы начинаем смотреть СО СЛЕДУЮЩЕГО элемента (i+1)
            # и идем до САМОГО КОНЦА списка (n).

            # 4. Сравнение
            if arr[j] < arr[min_index]:
                # Если число, на которое мы смотрим (arr[j]), МЕНЬШЕ того,
                # которое мы СЧИТАЛИ минимальным до этого (arr[min_index])...

                # 5. Запомнить Новое Место Минимума
                min_index = j
                # ...то теперь НАСТОЯЩИЙ минимум находится на месте j! Запоминаем этот НОВЫЙ индекс.
                # Теперь min_index указывает на место самого маленького числа, найденного НА ДАННЫЙ МОМЕНТ.

        # 6. Обмен Местами (После того, как внутренний цикл ЗАКОНЧИЛСЯ)
        # Теперь min_index ТОЧНО указывает на место самого маленького числа во всей
        # неотсортированной части (от i до конца).
        arr[i], arr[min_index] = arr[min_index], arr[i]
        # Меняем местами число, которое СТОЯЛО на месте i, с НАЙДЕННЫМ самым маленьким числом.
        # Теперь на месте i ГАРАНТИРОВАННО стоит правильное (самое маленькое из оставшихся) число.
        # Мы "зафиксировали" элемент на позиции i.

# Пример:
numbers = [64, 25, 12, 22, 11]
selection_sort(numbers) # Запускаем
print(numbers)          # Получаем: [11, 12, 22, 25, 64]