Есть рюкзак, который выдерживает не более $10$ кг.
Есть несколько предметов, у каждого есть:

- вес (сколько он «занимает» места/массы),
- ценность (насколько он нам «полезен»).

Нужно:

- выбрать какие‑то предметы,
- чтобы суммарный вес не превышал $10$,
- а суммарная ценность была как можно больше.

При этом каждый предмет можно взять либо:

- 0 раз (не брать),
- 1 раз (взять).

Это и есть задача 0/1‑рюкзака.

Почему просто «перебрать всё» — плохо?
Потому что при большом количестве предметов вариантов очень много (экспонента: $2^n$). Динамическое программирование (ДП) позволяет избежать полного перебора, храня промежуточные результаты в таблице.

***

### Полный код (а потом разбор)

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        int[] weights = { 2, 3, 4, 5, 9 };
        int[] values  = { 3, 4, 5, 8, 10 };
        int capacity = 10;
        int n = weights.Length;

        int[,] dp = new int[n + 1, capacity + 1];

        for (int i = 1; i <= n; i++)
        {
            int wi = weights[i - 1];
            int vi = values[i - 1];

            for (int w = 0; w <= capacity; w++)
            {
                dp[i, w] = dp[i - 1, w];

                if (wi <= w)
                {
                    int candidate = dp[i - 1, w - wi] + vi;
                    if (candidate > dp[i, w])
                        dp[i, w] = candidate;
                }
            }
        }

        int maxValue = dp[n, capacity];

        List<int> chosen = new List<int>();
        int remW = capacity;
        int item = n;

        while (item > 0 && remW > 0)
        {
            if (dp[item, remW] == dp[item - 1, remW])
            {
                item--;
            }
            else
            {
                chosen.Add(item);
                remW -= weights[item - 1];
                item--;
            }
        }
        chosen.Reverse();

        Console.WriteLine($"Максимальная ценность: {maxValue}");

        int totalWeight = 0;
        Console.WriteLine("Выбранные предметы (номер, вес, ценность):");
        foreach (int idx in chosen)
        {
            int w = weights[idx - 1];
            int v = values[idx - 1];
            totalWeight += w;
            Console.WriteLine($"  #{idx}: вес = {w}, ценность = {v}");
        }

        Console.WriteLine($"Суммарный вес: {totalWeight}");
    }
}
```


***

### Шаг 1. Входные данные: что у нас есть

```csharp
int[] weights = { 2, 3, 4, 5, 9 };
int[] values  = { 3, 4, 5, 8, 10 };
int capacity = 10;
int n = weights.Length;
```

Почему именно так:

- `weights` — массив весов.
`weights[0] = 2`, `weights[1] = 3`, …, `weights[4] = 9`.
- `values` — массив ценностей.
`values[0] = 3`, `values[1] = 4`, …, `values[4] = 10`.

Важно: предмет с индексом `0` имеет вес `weights[0]` и ценность `values[0]`.
То есть пары:

1. вес 2, ценность 3
2. вес 3, ценность 4
3. вес 4, ценность 5
4. вес 5, ценность 8
5. вес 9, ценность 10

`capacity = 10` — рюкзак максимум 10 кг.
`n = weights.Length` — количество предметов, здесь 5.

Зачем хранить в массивах?

- Удобно пробегать по всем предметам в цикле `for` по индексу.
- Вес и ценность связаны по индексу.

***

### Шаг 2. Таблица dp: что это и зачем

```csharp
int[,] dp = new int[n + 1, capacity + 1];
```

`dp` — это **двумерный массив** (таблица).

Идея:
`dp[i, w]` = максимальная суммарная ценность,
которую можно набрать, если:

- мы смотрим только на **первые i предметов** (из 5),
- и у нас есть рюкзак вместимости **ровно w** (0..10).

Почему размер `n + 1` и `capacity + 1`?

- Индекс `i` идёт от 0 до `n` включительно:
    - `i = 0` — вообще нет предметов,
    - `i = 1` — только 1-й предмет,
    - ...
    - `i = n` — все предметы.
- Индекс `w` идёт от 0 до `capacity` включительно:
    - `w = 0` — рюкзак нулевой вместимости,
    - `w = 1,2,...,10` — все варианты вместимости.

Почему базово `dp` заполнится нулями?

- В C\# массивы чисел по умолчанию заполняются нулями.
- Логика тоже совпадает:
    - если `i = 0` (нет предметов) — максимальная ценность 0;
    - если `w = 0` (вместимость 0) — тоже ценность 0.

***

### Шаг 3. Основной ДП-цикл: заполняем таблицу

```csharp
for (int i = 1; i <= n; i++)
{
    int wi = weights[i - 1];
    int vi = values[i - 1];

    for (int w = 0; w <= capacity; w++)
    {
        dp[i, w] = dp[i - 1, w];

        if (wi <= w)
        {
            int candidate = dp[i - 1, w - wi] + vi;
            if (candidate > dp[i, w])
                dp[i, w] = candidate;
        }
    }
}
```

Разберём это по уровням.

#### 3.1. Внешний цикл по предметам

```csharp
for (int i = 1; i <= n; i++)
{
    int wi = weights[i - 1];
    int vi = values[i - 1];
    ...
}
```

- `i` = 1…5 — сколько первых предметов мы сейчас учитываем.
- `weights[i - 1]` — вес текущего предмета (индексация в массивах с 0).
- `values[i - 1]` — ценность текущего предмета.

Почему `i - 1`?

- В задачах обычно нумеруем предметы с 1: «предмет 1, 2, 3…».
- В массивах в C\# индексация с 0.
Поэтому: предмет номер `i` лежит в массивах под индексом `i-1`.

`wi` и `vi` — просто сокращения, чтобы в цикле было меньше писать и легче читать:

- `wi` = `weights[i-1]` — вес предмета `i`.
- `vi` = `values[i-1]` — ценность предмета `i`.


#### 3.2. Внутренний цикл по возможной вместимости

```csharp
for (int w = 0; w <= capacity; w++)
{
    dp[i, w] = dp[i - 1, w];

    if (wi <= w)
    {
        int candidate = dp[i - 1, w - wi] + vi;
        if (candidate > dp[i, w])
            dp[i, w] = candidate;
    }
}
```

Этот цикл идёт по всем возможным «текущим размерам рюкзака» от 0 до 10.

Для каждого `w` мы решаем такой вопрос:

> Если у меня есть:
> - первые `i` предметов,
> - рюкзак вместимости `w`,
>
> то какая **максимальная ценность**?

Решаем через два варианта — **не брать** и **взять** текущий предмет.

##### Вариант 1: не брать предмет `i`

```csharp
dp[i, w] = dp[i - 1, w];
```

Почему так:

- Если предмет `i` **не берём**, то у нас всё как будто его нет.
- То есть ответ тот же, что и для **первых `i-1` предметов** и такой же вместимости `w`.
- Поэтому просто копируем значение сверху (из предыдущей строки таблицы).


##### Вариант 2: попробовать взять предмет `i`

Сначала проверка:

```csharp
if (wi <= w)
{
    ...
}
```

Почему:

- Если вес предмета `wi` **больше**, чем текущая вместимость `w`,
он **физически не помещается** в рюкзак.
- Поэтому нет смысла даже пробовать брать его:
вариант «взять» недопустим.

Если же `wi <= w`, то:

```csharp
int candidate = dp[i - 1, w - wi] + vi;
if (candidate > dp[i, w])
    dp[i, w] = candidate;
```

Что это значит:

- Мы хотим **взять** предмет `i`.
- Тогда:
    - этот предмет даёт ценность `vi`,
    - он занимает вес `wi`,
    - остаётся «свободным» вес `w - wi`.
- Для оставшегося веса `w - wi` и только первых `i-1` предметов
**лучший** результат хранится в `dp[i - 1, w - wi]`.
- Если взять этот оптимальный набор + предмет `i`,
суммарная ценность = `dp[i - 1, w - wi] + vi`.

Мы называем её `candidate` — «кандидат на лучший ответ».

Дальше сравниваем:

- что лучше:
    - уже посчитанный «не брать» (`dp[i, w]`),
    - или «взять» (`candidate`)?

И берём максимум:

```csharp
if (candidate > dp[i, w])
    dp[i, w] = candidate;
```

В математике это записывают как:

$$
dp[i][w] = \max\Big( dp[i-1][w],\ dp[i-1][w - w_i] + v_i \Big)
$$

***

### Шаг 4. Ответ — максимальная ценность

```csharp
int maxValue = dp[n, capacity];
```

Почему именно так:

- `n` — это «берём все предметы».
- `capacity` — максимальная вместимость рюкзака (10).
- `dp[n, capacity]` — это как раз определение:
«лучшая ценность при всех предметах и полном возможном весе».

Это и есть ответ задачи: **наилучшая возможная суммарная ценность**.

***

### Шаг 5. Восстановление, какие предметы взяли

Таблица `dp` говорит, «какую ценность можно получить», но не говорит напрямую, **какие именно предметы** выбраны. Поэтому идём **обратно по таблице**.

```csharp
List<int> chosen = new List<int>();
int remW = capacity;
int item = n;
```

- `chosen` — список выбранных предметов (сюда будем добавлять номера).
- `remW` — оставшаяся вместимость, с которой мы «идём назад».
Начинаем с полной (`capacity` = 10).
- `item` — текущий номер предмета, с которого «откручиваемся» назад.
Начинаем с `n` (последний предмет).


#### Цикл обратного прохода

```csharp
while (item > 0 && remW > 0)
{
    if (dp[item, remW] == dp[item - 1, remW])
    {
        item--;
    }
    else
    {
        chosen.Add(item);
        remW -= weights[item - 1];
        item--;
    }
}
chosen.Reverse();
```

Логика:

Мы смотрим на `dp[item, remW]` и сравниваем с `dp[item - 1, remW]`.

1. Если **равны**:

```csharp
if (dp[item, remW] == dp[item - 1, remW])
{
    item--;
}
```

Вопрос: *почему это значит, что предмет `item` не взяли?*
    - `dp[item, remW]` — лучшая ценность с предметами `1..item` и вместимостью `remW`.
    - `dp[item - 1, remW]` — лучшая ценность с предметами `1..(item-1)` при той же вместимости.
    - Если при добавлении предмета `item` значение **не выросло**,
значит, он **нам не понадобился** для оптимального ответа.
    - То есть оптимальный набор не включает этот предмет,
и можно просто перейти к предыдущему: `item--`.
2. Если **не равны**:

```csharp
else
{
    chosen.Add(item);
    remW -= weights[item - 1];
    item--;
}
```

Тогда:
    - Значит, при учёте предмета `item` значение **улучшилось**.
    - Следовательно, **этот предмет был взят** в оптимальном наборе.
    - Добавляем его номер в список: `chosen.Add(item)`.
    - Поскольку мы как бы «отматываем решение назад»,
вычитаем его вес из оставшейся вместимости:

```csharp
remW -= weights[item - 1];
```

    - И переходим к предыдущему предмету: `item--`.

Цикл идёт, пока:

- не кончатся предметы (`item > 0`),
- и пока ещё есть какой‑то оставшийся вес (`remW > 0`).


#### Почему потом `Reverse()`?

```csharp
chosen.Reverse();
```

Мы шли **с конца**:

- сначала смотрели предмет `n`,
- потом `n-1`, …,
- в список `chosen` добавляли в порядке «с конца к началу».

То есть список получился в обратном порядке.
Чтобы сделать его «красивым» (от меньших номеров к большим), разворачиваем.

***

### Шаг 6. Вывод результата

```csharp
Console.WriteLine($"Максимальная ценность: {maxValue}");

int totalWeight = 0;
Console.WriteLine("Выбранные предметы (номер, вес, ценность):");
foreach (int idx in chosen)
{
    int w = weights[idx - 1];
    int v = values[idx - 1];
    totalWeight += w;
    Console.WriteLine($"  #{idx}: вес = {w}, ценность = {v}");
}

Console.WriteLine($"Суммарный вес: {totalWeight}");
```

Что тут происходит:

1. Печатаем максимальную ценность, найденную ДП:

```csharp
Console.WriteLine($"Максимальная ценность: {maxValue}");
```

2. Готовим переменную для суммарного веса:

```csharp
int totalWeight = 0;
```

3. Для каждого выбранного предмета `idx`:

```csharp
int w = weights[idx - 1];
int v = values[idx - 1];
totalWeight += w;
Console.WriteLine($"  #{idx}: вес = {w}, ценность = {v}");
```

    - По номеру предмета `idx` достаём его вес и ценность из массивов.
    - Прибавляем вес к `totalWeight`.
    - Выводим строку про этот предмет.
4. В конце печатаем итоговый суммарный вес:

```csharp
Console.WriteLine($"Суммарный вес: {totalWeight}");
```


***

### Итоговое интуитивное резюме

- Таблица `dp` отвечает на вопрос:
«Если у меня первые `i` предметов и рюкзак на `w` кг,
какой максимум ценности я могу получить?».
- Заполняем таблицу строка за строкой:
    - на каждой ячейке решаем:
взять текущий предмет или не взять,
и выбираем то, что даёт больший результат.
- В конце у нас:
    - `dp[n, capacity]` — лучшая ценность;
    - обратным проходом через таблицу узнаём, какие именно предметы вошли в этот лучший вариант.

