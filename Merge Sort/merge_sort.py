def merge_sort(arr):
    # arr - твой список чисел, например [38, 27, 43, 3, 9, 82, 10]

    # 1. Проверка на "Атом" (Базовый случай рекурсии)
    if len(arr) > 1:
        # Зачем? Если в списке 1 или 0 элементов, он уже отсортирован.
        # Это точка остановки для нашего деления. Если больше 1 - надо делить!

        # 2. Находим Середину и Делим
        mid = len(arr) // 2  # Находим индекс середины (// - деление без остатка)
        left_part = arr[:mid]  # Левая часть: от начала до середины (не включая)
        right_part = arr[mid:] # Правая часть: от середины до конца

        # 3. Рекурсивный Вызов (Продолжаем Делить)
        merge_sort(left_part)  # Просим отсортировать левую половинку ТЕМ ЖЕ СПОСОБОМ
        merge_sort(right_part) # Просим отсортировать правую половинку ТЕМ ЖЕ СПОСОБОМ
        # Важно: эти вызовы будут делить дальше, пока не дойдут до списков из 1 элемента.
        # Только ПОСЛЕ того, как обе половинки ВЕРНУТСЯ (т.е. будут отсортированы),
        # мы перейдем к следующему шагу - слиянию.

        # --- Вот здесь начинается СЛИЯНИЕ ---
        # К этому моменту left_part и right_part УЖЕ ОТСОРТИРОВАНЫ (благодаря рекурсии)

        # 4. Подготовка к Слиянию (Счетчики)
        i = 0  # Указатель (индекс) для текущего элемента в left_part
        j = 0  # Указатель (индекс) для текущего элемента в right_part
        k = 0  # Указатель (индекс) для МЕСТА в ИСХОДНОМ списке arr, куда мы будем класть слитые элементы

        # 5. Основной Цикл Слияния
        while i < len(left_part) and j < len(right_part):
            # Зачем? Пока есть элементы И в левой, И в правой части для сравнения...
            if left_part[i] < right_part[j]:
                # Если элемент из левой части меньше...
                arr[k] = left_part[i] # ...кладем ЕГО в основной список arr на место k
                i += 1                # Сдвигаем указатель левой части вперед
            else:
                # Иначе (если правый меньше или равен левому)...
                arr[k] = right_part[j] # ...кладем ПРАВЫЙ элемент в основной список arr
                j += 1                 # Сдвигаем указатель правой части вперед
            k += 1                     # В любом случае, мы заняли место k, сдвигаем указатель основного списка

        # 6. Добавление Остатков (Хвостов)
        # Может случиться, что один из списков (left_part или right_part) закончился раньше.
        # А в другом еще остались элементы (они уже отсортированы и точно больше всех, что мы уже положили).
        # Их нужно просто докопировать в конец.

        # Если остались элементы в ЛЕВОЙ части:
        while i < len(left_part):
            arr[k] = left_part[i]
            i += 1
            k += 1

        # Если остались элементы в ПРАВОЙ части:
        while j < len(right_part):
            arr[k] = right_part[j]
            j += 1
            k += 1

    # Если len(arr) <= 1 (базовый случай), функция просто ничего не делает
    # (или можно было бы написать 'return arr', но здесь мы меняем список "на месте")

# Пример:
numbers = [38, 27, 43, 3, 9, 82, 10]
merge_sort(numbers) # Запускаем сортировку
print(numbers)      # Получаем: [3, 9, 10, 27, 38, 43, 82]