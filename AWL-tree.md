
# Руководство по AVL-деревьям и видам сбалансированных деревьев

**AVL-дерево** — первый в истории самоcбалансирующийся вариант бинарного дерева поиска (BST), гарантирующий логарифмическую высоту дерева после любых изменений структуры. Это обеспечивает быстрый поиск, вставку и удаление для любых сценариев данных. Руководство раскрывает работу AVL-дерева простым языком, рассматривает базовые понятия, примеры, отличие от других видов деревьев и раскрывает их место в инженерных задачах.

***

## Что такое AVL-дерево

**AVL-дерево** — самоcбалансирующееся бинарное дерево поиска, в котором для каждого узла разница высот между левым и правым поддеревом (баланс-фактор) не превышает 1:

$$
-1 \leq \text{Balance Factor} \leq 1
$$

Это строгое условие предотвращает вырождение дерева в линейную структуру и всегда гарантирует O(log n) высоту дерева для n узлов.

### Основные характеристики:

- **Самостоятельно балансируется** после любой вставки или удаления.
- Каждый узел хранит свой **баланс-фактор** (разность высот поддеревьев).
- Все стандартные операции (поиск, добавление, удаление) занимают O(log n) времени.
- Основа для многих критически важных алгоритмов в базах данных и системах индексации.

***

## Ключевые термины AVL-деревьев

- **Node (Узел):** Контейнер данных, указывает на левый и правый дочерние элементы.
- **Root (Корень):** Верхний узел дерева.
- **Height (Высота):** Количество рёбер на самом длинном пути к листу от данного узла.
- **Balance Factor (Баланс-фактор):** $\text{height(left)} - \text{height(right)}$.
- **Rotation (Ротация):** Местный поворот узлов для восстановления баланса.

***

## Механизм балансировки. Типы ротаций

**Ротации** – локальные преобразования дерева для поддержания баланса. В AVL деревьях встречаются четыре случая:


| Тип ротации | Когда применяется | Как исправить |
| :-- | :-- | :-- |
| Right (LL) | Левое поддерево слишком велико | Правый поворот |
| Left (RR) | Правое поддерево слишком велико | Левый поворот |
| Left-Right | Левый потомок «тяжёлый справа» | Лево-потомка: лево, родителя: вправо |
| Right-Left | Правый потомок «тяжёлый слева» | Право-потомка: вправо, родителя: влево |

Ротации эффективны и работают за O(1), а основная операция балансировки требует не больше O(log n) шагов на полное восстановление структуры.

***

## Базовые операции для AVL-дерева

### Поиск

Как и в обычном BST: сравнение ключей и спуск влево/вправо — O(log n).

### Вставка

1. Стандартная BST-вставка.
2. Подъём вверх с обновлением высоты и проверкой баланса.
3. В случае нарушения баланса — ротация одним из четырёх способов.

### Удаление

1. Обычное удаление из BST.
2. Пересчёт баланса снизу вверх.
3. Возможны **несколько ротаций**, если дерево теряет баланс в нескольких узлах.

***

## Пример (Python):

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = self.right = None
        self.height = 1

class AVLTree:
    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        if not node: return 0
        return self.get_height(node.left) - self.get_height(node.right)

    def right_rotate(self, z):
        y = z.left
        z.left = y.right
        y.right = z
        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def left_rotate(self, z):
        y = z.right
        z.right = y.left
        y.left = z
        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, root, key):
        if not root: return Node(key)
        if key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))
        balance = self.get_balance(root)
        if balance > 1 and key < root.left.key:  # LL
            return self.right_rotate(root)
        if balance < -1 and key > root.right.key:  # RR
            return self.left_rotate(root)
        if balance > 1 and key > root.left.key:  # LR
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)
        if balance < -1 and key < root.right.key:  # RL
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)
        return root
```


***

## Преимущества и недостатки AVL-деревьев

**Преимущества:**

- Строгий баланс гарантирует O(log n) для всех операций.
- Из-за меньшей высоты поиск быстрее, чем в других структурах (например, красно-чёрных деревьях).
- Сохраняет упорядоченность для быстрого обхода в порядке возрастания.

**Недостатки:**

- Более сложная реализация по сравнению с обычным BST.
- Частые ротации при вставке и удалении (выше overhead по сравнению с Red-Black Tree в сценариях с массивными изменениями).

***

## Применения

- Индексация и поиск в базах данных.
- Файловые и операционные системы (управление памятью).
- Реализация эффективных словарей и динамических множеств.
- Сетевые маршрутизаторы (динамические таблицы маршрутов).

***

## Сравнение с другими видами деревьев

| Признак | AVL Tree | Red-Black Tree | Splay Tree | Обычный BST |
| :-- | :-- | :-- | :-- | :-- |
| Балансировка | Строгая | Менее строгая | Самоорганизация по доступу | Нет |
| Высота | ≤ 1.44 log₂(n) | ≤ 2 log₂(n) | Амортизированная | До n (линейно) |
| Операции | Всегда O(log n) | Всегда O(log n) | Амортизированно O(log n) | В худшем O(n) |
| Быстрота поиска | Быстрее (меньше высота) | Чуть медленнее | Может быть быстрее* | Медленно для несбалансир. |
| Soft real-time | Подходит | Подходит | Нет | Нет |
| Вставка/удаление | Медленнее, больше ротаций | Меньше ротаций, быстрее | Амортизировано быстро | Просто |
| Применение | Индексация, ОС | STL, картографирование, ОС | Частный случай | Легкие задачи |

*

***

## Другие типы деревьев (справочно)

- **Обычное BST** — не гарантирует сбалансированность.
- **Красно-чёрное дерево** — цветовое свойство; менее строгое, реже балансируется, быстрое удаление/добавление.
- **B-дерево, B+-дерево** — обобщение BST для внешней памяти и работы с огромными массивами данных.
- **Splay-дерево** — ротация по факту доступа (часто используемые элементы ближе к корню).
- **Куча (Heap)** — специализированная для реализации очередей с приоритетами, но не BST.
- **Полное/Совершенное/Дегенеративное/Смещённое бинарное** — виды по заполнению уровней и структуре дерева.

***

## Когда использовать AVL-дерева

- Если требуется максимально предсказуемое время доступа и строгая поддержка баланса.
- Для частых операций поиска и изменения набора элементов.
- В приложениях, чувствительных к худшим случаям временной сложности (реальное время, критические системы).

***

## Заключение

**AVL-дерево** — фундаментальная и максимально инженерно предсказуемая структура среди деревьев поиска. Рекомендуется для сценариев, где требуется логарифмическое время работы и отсутствует склонность к «скачкообразным» изменениям структуры данных, присущая другим деревьям. При этом для массовых изменений или встраивания в классические библиотеки STL (`map`, `set`) чаще выбираются более простые по поддержке Red-Black-деревья.
