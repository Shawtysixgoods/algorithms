def quick_sort(arr):
    # arr - твой список чисел, например [10, 7, 8, 9, 1, 5]

    # 1. Базовый Случай (Условие Остановки)
    if len(arr) <= 1:
        return arr
        # Зачем? Это ОЧЕНЬ важно! Если в списке 0 или 1 число, он УЖЕ отсортирован.
        # Делить дальше нечего. Мы просто возвращаем этот список как есть.
        # Без этого условия сортировка будет пытаться делиться бесконечно!

    # 2. Выбор Опорного Элемента
    pivot = arr[0]
    # Зачем? Нам нужен "командир" для разделения.
    # Здесь мы просто берем САМЫЙ ПЕРВЫЙ элемент списка как опорный.
    # Можно выбирать и по-другому (середину, случайный), но так проще всего показать.
    # pivot - это наше опорное значение (в первом проходе это 10).

    # 3. Готовим Места для Групп
    left = []    # Список для тех, кто МЕНЬШЕ опорного
    right = []   # Список для тех, кто БОЛЬШЕ опорного
    equal = []   # Список для тех, кто РАВЕН опорному (важно, если числа повторяются)

    # 4. Разделение (Цикл)
    for x in arr:
        # Зачем? Проходим по КАЖДОМУ числу в ТЕКУЩЕМ списке arr.
        # x - это число, на которое мы смотрим прямо сейчас.

        # 5. Сравнение с Опорным и Распределение
        if x < pivot:
            left.append(x)  # Если число меньше опорного - кидаем в левый список.
        elif x > pivot:
            right.append(x) # Если число больше опорного - кидаем в правый список.
        else:
            equal.append(x) # Если число равно опорному - кидаем в "равный" список.

    # 6. Волшебство Рекурсии и Сборка
    # Теперь у нас есть три списка: left, equal, right.
    # Списку equal сортировка не нужна - там все одинаковые.
    # А вот left и right ЕЩЕ НЕ ОТСОРТИРОВАНЫ внутри себя!
    # Мы снова вызываем НАШУ ЖЕ ФУНКЦИЮ quick_sort для них!
    return quick_sort(left) + equal + quick_sort(right)
    # Что здесь происходит:
    # - quick_sort(left): Мы просим отсортировать левую часть ТОЧНО ТАК ЖЕ.
    #                    Функция вызовет сама себя для списка left.
    # - quick_sort(right): Мы просим отсортировать правую часть ТОЧНО ТАК ЖЕ.
    #                    Функция вызовет сама себя для списка right.
    # - Когда эти вызовы ВЕРНУТ уже отсортированные left и right...
    # - ...мы просто "склеиваем" их: [отсорт. левый] + [равные опорному] + [отсорт. правый].
    # - И этот склеенный, полностью отсортированный список ВОЗВРАЩАЕТСЯ как результат
    #   работы ТЕКУЩЕГО вызова quick_sort.

# Пример:
numbers = [10, 7, 8, 9, 1, 5]
sorted_numbers = quick_sort(numbers) # Запускаем
print(sorted_numbers)                # Получаем: [1, 5, 7, 8, 9, 10]