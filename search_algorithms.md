## 1. Линейный (последовательный) поиск

### Описание и принцип работы

Линейный поиск — это самый простой и интуитивный алгоритм поиска. Он работает по принципу **последовательного перебора**: проверяет каждый элемент массива по порядку, начиная с первого, пока не найдёт нужный элемент или не дойдёт до конца массива.

**Принцип работы:**

1. Начинаем с первого элемента массива (индекс 0)
2. Сравниваем текущий элемент с искомым значением
3. Если элемент найден — возвращаем его индекс
4. Если не найден — переходим к следующему элементу
5. Повторяем шаги 2-4 до конца массива
6. Если дошли до конца и ничего не нашли — элемента нет в массиве

**Преимущества:**

- Прост в реализации и понимании
- Работает с неотсортированными данными
- Не требует предварительной обработки массива

**Недостатки:**

- Медленный для больших массивов
- Проверяет все элементы в худшем случае


### Сложность алгоритма

**Временная сложность:**

- **Лучший случай:** O(1) — элемент находится на первой позиции
- **Средний случай:** O(n/2) ≈ O(n) — элемент в середине массива
- **Худший случай:** O(n) — элемент в конце или отсутствует

**Пространственная сложность:** O(1) — не требует дополнительной памяти

### Термины

- **Временная сложность** — количество операций, которое выполняет алгоритм в зависимости от размера входных данных (n)
- **O(n)** (О-большое) — математическая нотация для описания роста времени выполнения. O(n) означает линейный рост: если данных в 2 раза больше, времени нужно в 2 раза больше
- **Пространственная сложность** — объём дополнительной памяти, необходимый алгоритму


### Пример кода

```cpp
#include <iostream>
#include <vector>
#include <optional>
using namespace std;

/*  
 * ЛИНЕЙНЫЙ ПОИСК  
 * Поочерёдно перебирает все элементы массива для поиска нужного значения.  
 * Временная сложность: O(n), где n — количество элементов.
 * Применяется к неотсортированным данным.  
 */

// Функция линейного поиска в массиве.
// Параметры:
//   data - вектор целых чисел для поиска
//   target - искомое значение
// Возвращает: optional<size_t> - индекс найденного элемента или nullopt
optional<size_t> linear_search(const vector<int>& data, int target) {
    // Проходим по всем элементам массива от начала до конца
    for (size_t i = 0; i < data.size(); ++i) {
        // Сравниваем текущий элемент с искомым значением
        if (data[i] == target) {
            return i;  // Найдено! Возвращаем индекс элемента
        }
    }
    // Прошли весь массив и ничего не нашли
    return nullopt; // Элемент отсутствует в массиве
}

int main() {
    // Создаём тестовый массив (неотсортированный)
    vector<int> v = {3, 5, 7, 9, 11};
    int target = 7;
    
    cout << "Ищем элемент " << target << " в массиве: ";
    for (int x : v) cout << x << " ";
    cout << "\n";
    
    // Вызываем функцию поиска
    if (auto result = linear_search(v, target)) {
        cout << "Элемент найден на позиции: " << *result << '\n';
    } else {
        cout << "Элемент не найден\n";
    }
    
    return 0;
}
```


***

## 2. Бинарный (двоичный) поиск

### Описание и принцип работы

Бинарный поиск — это эффективный алгоритм поиска, который работает по принципу **"разделяй и властвуй"**. Он требует, чтобы массив был **отсортирован** (по возрастанию или убыванию).

**Принцип работы:**

1. Определяем границы поиска: левую (начало массива) и правую (конец массива)
2. Вычисляем средний индекс между левой и правой границей
3. Сравниваем элемент в середине с искомым значением:
    - Если равны — элемент найден, возвращаем индекс
    - Если средний элемент меньше искомого — ищем в правой половине (сдвигаем левую границу)
    - Если средний элемент больше искомого — ищем в левой половине (сдвигаем правую границу)
4. Повторяем шаги 2-3, пока не найдём элемент или границы не сойдутся

**Ключевая идея:** на каждом шаге мы отбрасываем половину массива, что делает поиск очень быстрым.

**Преимущества:**

- Очень быстрый для больших массивов
- Логарифмическая сложность O(log n)

**Недостатки:**

- Требует отсортированный массив
- Чуть сложнее в реализации


### Сложность алгоритма

**Временная сложность:**

- **Лучший случай:** O(1) — элемент в середине массива
- **Средний случай:** O(log n)
- **Худший случай:** O(log n) — элемент в конце или отсутствует

**Пространственная сложность:** O(1) для итеративной версии

### Термины

- **Отсортированный массив** — массив, в котором элементы расположены в порядке возрастания или убывания
- **O(log n)** — логарифмическая сложность. При удвоении размера данных время увеличивается только на одну операцию. Например: для 1000 элементов — 10 операций, для 1 000 000 — 20 операций
- **Разделяй и властвуй** — стратегия, при которой задача делится на меньшие подзадачи


### Пример кода

```cpp
#include <iostream>
#include <vector>
#include <optional>
using namespace std;

/*  
 * БИНАРНЫЙ (ДВОИЧНЫЙ) ПОИСК  
 * Эффективен для отсортированных массивов.  
 * Делит массив пополам на каждом шаге, сокращая область поиска.  
 * Временная сложность: O(log n) — логарифмическая.  
 */

// Функция бинарного поиска.
// Параметры:
//   sorted_data - отсортированный вектор целых чисел
//   target - искомое значение
// Возвращает: optional<size_t> - индекс найденного элемента или nullopt
optional<size_t> binary_search(const vector<int>& sorted_data, int target) {
    size_t left = 0;                    // Левая граница области поиска
    size_t right = sorted_data.size();  // Правая граница (невключительно)
    
    // Пока есть область для поиска
    while (left < right) {
        // Вычисляем средний индекс (избегаем переполнения)
        size_t mid = left + (right - left) / 2;
        
        // Проверяем элемент в середине
        if (sorted_data[mid] == target) {
            return mid; // Нашли! Возвращаем индекс
        } 
        else if (sorted_data[mid] < target) {
            // Искомый элемент больше среднего — ищем в правой половине
            left = mid + 1;
        } 
        else {
            // Искомый элемент меньше среднего — ищем в левой половине
            right = mid;
        }
    }
    
    // Область поиска исчерпана, элемент не найден
    return nullopt;
}

int main() {
    // ВАЖНО: массив должен быть отсортирован!
    vector<int> v = {1, 3, 5, 7, 9, 11, 13, 15};
    int target = 7;
    
    cout << "Ищем элемент " << target << " в отсортированном массиве: ";
    for (int x : v) cout << x << " ";
    cout << "\n";
    
    // Вызываем бинарный поиск
    if (auto result = binary_search(v, target)) {
        cout << "Элемент найден на позиции: " << *result << '\n';
    } else {
        cout << "Элемент не найден\n";
    }
    
    return 0;
}
```


***

## 3. Интерполяционный поиск

### Описание и принцип работы

Интерполяционный поиск — это улучшенная версия бинарного поиска для **равномерно распределённых** отсортированных данных. Вместо того чтобы всегда делить массив пополам, он **оценивает** позицию искомого элемента с помощью математической формулы интерполяции.

**Аналогия:** Представьте, что вы ищете слово в словаре. Если ищете слово на "Я", вы откроете словарь ближе к концу, а не к середине. Это и есть интерполяция — умная оценка позиции.

**Принцип работы:**

1. Вычисляем предполагаемую позицию элемента по формуле:

```
pos = low + ((target - arr[low]) / (arr[high] - arr[low])) × (high - low)
```

2. Проверяем элемент на вычисленной позиции
3. Если не совпал — корректируем границы и повторяем

**Преимущества:**

- Быстрее бинарного поиска для равномерных данных
- Может достичь O(log log n) для идеально распределённых данных

**Недостатки:**

- Требует отсортированный и равномерно распределённый массив
- В худшем случае (неравномерные данные) может деградировать до O(n)


### Сложность алгоритма

**Временная сложность:**

- **Лучший случай:** O(1)
- **Средний случай:** O(log log n) для равномерных данных
- **Худший случай:** O(n) для неравномерных данных

**Пространственная сложность:** O(1)

### Термины

- **Равномерное распределение** — данные распределены с примерно одинаковыми промежутками (например: 10, 20, 30, 40...)
- **Интерполяция** — метод оценки значения между известными точками данных
- **O(log log n)** — двойная логарифмическая сложность, ещё быстрее чем O(log n)


### Пример кода

```cpp
#include <iostream>
#include <vector>
#include <optional>
using namespace std;

/*  
 * ИНТЕРПОЛЯЦИОННЫЙ ПОИСК  
 * Вариант бинарного поиска для равномерно распределённых данных.  
 * Оценивает позицию элемента с помощью формулы интерполяции.
 * Временная сложность: O(log log n) в среднем, O(n) в худшем случае.  
 */

// Функция интерполяционного поиска.
// Параметры:
//   sorted_data - отсортированный вектор с равномерным распределением
//   target - искомое значение
// Возвращает: optional<size_t> - индекс найденного элемента или nullopt
optional<size_t> interpolation_search(const vector<int>& sorted_data, int target) {
    size_t low = 0;                          // Нижняя граница
    size_t high = sorted_data.size() - 1;    // Верхняя граница
    
    // Проверяем, что искомое значение находится в диапазоне массива
    while (low <= high && 
           target >= sorted_data[low] && 
           target <= sorted_data[high]) {
        
        // Если остался один элемент
        if (low == high) {
            if (sorted_data[low] == target) 
                return low;
            else 
                return nullopt;
        }
        
        // Интерполяционная формула для оценки позиции
        // Вычисляем пропорцию: насколько target близок к low относительно диапазона
        double proportion = (double)(target - sorted_data[low]) / 
                           (sorted_data[high] - sorted_data[low]);
        
        // Применяем пропорцию к диапазону индексов
        size_t pos = low + (size_t)((high - low) * proportion);
        
        // Проверяем вычисленную позицию
        if (sorted_data[pos] == target) {
            return pos; // Найдено!
        } 
        else if (sorted_data[pos] < target) {
            // Искомое значение справа — сдвигаем нижнюю границу
            low = pos + 1;
        } 
        else {
            // Искомое значение слева — сдвигаем верхнюю границу
            high = pos - 1;
        }
    }
    
    // Элемент не найден или вышел за пределы диапазона
    return nullopt;
}

int main() {
    // Массив с равномерным распределением (разница между элементами одинаковая)
    vector<int> v = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int target = 70;
    
    cout << "Ищем элемент " << target << " в равномерно распределённом массиве:\n";
    for (int x : v) cout << x << " ";
    cout << "\n";
    
    // Вызываем интерполяционный поиск
    if (auto result = interpolation_search(v, target)) {
        cout << "Элемент найден на позиции: " << *result << '\n';
        cout << "Значение: " << v[*result] << '\n';
    } else {
        cout << "Элемент не найден\n";
    }
    
    return 0;
}
```


***

## 4. Экспоненциальный поиск

### Описание и принцип работы

Экспоненциальный поиск — это гибридный алгоритм, который объединяет два подхода:

1. **Экспоненциальное расширение диапазона** — быстро находит диапазон, где может находиться элемент
2. **Бинарный поиск** — точно ищет элемент в найденном диапазоне

**Принцип работы:**

1. Проверяем первый элемент массива
2. Начинаем с индекса i = 1 и удваиваем его (1, 2, 4, 8, 16, 32...)
3. На каждом шаге проверяем: arr[i] ≤ target?
4. Как только arr[i] > target, мы нашли диапазон: [i/2, i]
5. Применяем бинарный поиск в этом диапазоне

**Ключевая идея:** быстро "перепрыгиваем" через большие участки массива, затем точно ищем в небольшом диапазоне.

**Преимущества:**

- Эффективен для неограниченных или очень больших массивов
- Хорош, когда искомый элемент находится ближе к началу
- Сложность O(log n)

**Недостатки:**

- Требует отсортированный массив
- Для обычных задач бинарный поиск проще и достаточен


### Сложность алгоритма

**Временная сложность:**

- **Лучший случай:** O(1)
- **Средний и худший случай:** O(log n)

**Пространственная сложность:** O(1)

### Термины

- **Экспоненциальный рост** — удвоение значения на каждом шаге (1→2→4→8→16...)
- **Гибридный алгоритм** — алгоритм, сочетающий несколько подходов
- **Неограниченный массив** — массив, размер которого заранее не известен


### Пример кода

```cpp
#include <iostream>
#include <vector>
#include <optional>
#include <algorithm>
using namespace std;

/*  
 * ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК  
 * Быстро находит диапазон с экспоненциальными шагами (1, 2, 4, 8...),  
 * затем применяет бинарный поиск в найденном диапазоне.
 * Временная сложность: O(log n).
 * Эффективен для больших массивов и когда элемент ближе к началу.  
 */

// Вспомогательная функция: бинарный поиск в заданном диапазоне
// Параметры:
//   arr - массив для поиска
//   left, right - границы диапазона поиска
//   target - искомое значение
// Возвращает: индекс элемента или -1, если не найден
size_t binary_search_range(const vector<int>& arr, size_t left, size_t right, int target) {
    // Стандартный бинарный поиск в диапазоне [left, right]
    while (left <= right) {
        size_t mid = left + (right - left) / 2;
        
        if (arr[mid] == target)
            return mid;  // Найдено
        else if (arr[mid] < target)
            left = mid + 1;  // Ищем справа
        else
            right = mid - 1; // Ищем слева
    }
    return -1; // Не найдено
}

// Основная функция экспоненциального поиска
// Параметры:
//   arr - отсортированный вектор целых чисел
//   target - искомое значение
// Возвращает: optional<size_t> - индекс найденного элемента или nullopt
optional<size_t> exponential_search(const vector<int>& arr, int target) {
    // Проверка на пустой массив
    if (arr.empty()) 
        return nullopt;
    
    // Проверяем первый элемент отдельно
    if (arr[0] == target) 
        return 0;
    
    // Фаза 1: Экспоненциальное расширение диапазона
    size_t i = 1;
    // Удваиваем индекс, пока не выйдем за пределы или не превысим target
    while (i < arr.size() && arr[i] <= target) {
        i *= 2;  // Экспоненциальный рост: 1 → 2 → 4 → 8 → 16...
    }
    
    // Фаза 2: Бинарный поиск в найденном диапазоне [i/2, min(i, size-1)]
    size_t left = i / 2;                    // Предыдущая граница
    size_t right = min(i, arr.size() - 1);  // Текущая граница или конец массива
    
    size_t result = binary_search_range(arr, left, right, target);
    
    // Преобразуем результат в optional
    if (result != -1)
        return result;
    else
        return nullopt;
}

int main() {
    // Отсортированный массив для тестирования
    vector<int> v = {2, 3, 4, 10, 40, 50, 60, 70, 80, 90};
    int target = 40;
    
    cout << "Ищем элемент " << target << " в массиве:\n";
    for (int x : v) cout << x << " ";
    cout << "\n";
    
    // Демонстрация работы алгоритма
    cout << "\nХод экспоненциального поиска:\n";
    cout << "1. Проверяем arr[0] = " << v[0] << " (не равно " << target << ")\n";
    cout << "2. Экспоненциально расширяем: проверяем индексы 1, 2, 4, 8...\n";
    cout << "3. Находим диапазон и применяем бинарный поиск\n\n";
    
    // Вызываем экспоненциальный поиск
    if (auto result = exponential_search(v, target)) {
        cout << "Результат: элемент найден на позиции " << *result << '\n';
        cout << "Значение: " << v[*result] << '\n';
    } else {
        cout << "Элемент не найден\n";
    }
    
    return 0;
}
```


***

## Сравнительная таблица алгоритмов

| Характеристика | Линейный | Бинарный | Интерполяционный | Экспоненциальный |
| :-- | :-- | :-- | :-- | :-- |
| **Требует сортировки** | Нет | Да | Да | Да |
| **Временная сложность (средняя)** | O(n) | O(log n) | O(log log n) | O(log n) |
| **Временная сложность (худшая)** | O(n) | O(log n) | O(n) | O(log n) |
| **Пространственная сложность** | O(1) | O(1) | O(1) | O(1) |
| **Лучше всего для** | Малые массивы, неотсортированные данные | Большие отсортированные массивы | Равномерные данные | Большие массивы, элемент в начале |
| **Простота реализации** | Очень простой | Средняя | Средняя | Сложная |

## Когда что использовать?

- **Линейный поиск:** если массив маленький (< 100 элементов) или не отсортирован
- **Бинарный поиск:** универсальный выбор для отсортированных данных
- **Интерполяционный поиск:** когда данные отсортированы и равномерно распределены (числовые последовательности)
- **Экспоненциальный поиск:** когда массив очень большой или бесконечный, и вы предполагаете, что элемент в начале

